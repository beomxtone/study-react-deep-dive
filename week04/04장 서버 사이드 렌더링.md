# 04장: 서버 사이드 렌더링

## 4.1 서버 사이드 렌더링이란?

### 4.1.1 싱글 페이지 어플리케이션의 세상

> `싱글 페이지 애플리케이션(Single Page Application: SPA)`이란 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식

첫 페이지 이후에는 페이지 전환을 위한 모든 작업이 자바스크립트와 브라우저의 `history.pushState`, `history.replaceState`로 이루어져, 하나의 페이지에서 모든 작업이 처리된다.

SPA의 HTML 코드 `<body/>` 내부에는 아무 내용이 없다.

- 사이트 렌더링에 필요한 `<body/>` 내부의 내용을 자바스크립트 코드로 삽입한 이후에 렌더링하기 때문이다.
- 페이지 전환시에도 필요한 정보만 요청하여 `<body/>` 내부에 DOM을 추가, 수정, 삭제한다.
- 장점 : 최초 로딩 이후엔 서버를 거쳐 리소스를 받아올 일이 적어져 사용자에게 훌륭한 UI/UX 제공한다.
- 단점 : 최초 로딩할 자바스크립트 리소스가 커진다.

#### 전통적인 방식의 애플리케이션

- 페이지 전환 발생시마다 새롭게 페이지를 요청해 HTML 페이지를 다운로드한다.
- 페이지를 처음부터 새로 그려야 해서 `Flickering` 또는 `Flash of Unstyled Content (FOUC)` 현상이 발생할 수 있다.

#### 싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장

자바스크립트가 다양한 작업을 수행하게 되면서 모듈화가 진행되어 CommonJs와 AMD(Asynchronous Module Definition)이 등장했다.  
이후 Backbone.js, AngularJs등이 등장하며 MVx 프레임워크를 구현하기 시작했고, 인기에 힘입어 오늘날 React, Vue, Angular의 시대가 오게 된다.

싱글 페이지 애플리케이션, 즉 클라이언트 사이드 라우팅이 퍼지게 된 것은...

- 사용자에게 멋진 UX를 제공할 수 있다.
- 브라우저 내부에서 작동하는 자바스크립트만 잘 작성하면 되므로, 프론트엔드 개발자에게 간편한 개발 경험을 제공했다.

**JAM 스택**

> JAM (JavaScript, API, Markup)

프론트엔드는 자바스크립트, 마크업(HTML, CSS)을 미리 빌드하고 정적으로 사용자에게 제공하면 이후 작동이 사용자의 클라이언트에서 실행되므로 서버 확장성 문제에서 자유로워질 수 있다.  
LAMP (Linux, Apache, MySql, PHP/Python ...) 스택이 서버 의존적인 것에 비해 서버 확충의 부담이 감소했다.

JAM스택의 인기와 Node.js의 고도화에 따라 API 서버 자체도 자바스크립트로 구현하는 구조가 인기를 끌기 시작했다.

- MEAN (MongoDB, Express.js, AngluarJs, Node.js)
- MERN (MongoDB, Express.js, React, Node.js)

![google trend of stacks](https://github.com/fe-deep-dive/study-react-deep-dive/assets/55120738/09a390c5-7c24-4b41-9f32-802fc4dedb16)

_압도적인 MERN..._

#### 새로운 패러다임의 웹서비스를 향한 요구

> 웹 애플리케이션에서 제공하는 자바스크립트 리소스의 크기와 수가 모두 증가하기 시작했다.  
> 기기나 인터넷 속도 등 웹 환경은 개선되었지만, 웹페이지 로딩 시간, 인터랙션이 가능해지는 시간은 증가해 실제 사용자들의 체감은 예전과 같거나 더 느려졌다.

~~결국 CSR의 한계에 다시 SSR로 회귀엔딩~~

### 4.1.2 서버 사이드 렌더링이란?

> 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식

**장점**

- 최초 페이지 진입이 비교적 빠르다.

  페이지에 유의미한 정보가 그려지는 시간(First Contentful Paint)이 빨라질 수 있다.  
  일반적으로 HTTP 요청은 서버에서 수행하는 것이 더 빠르고, HTML을 서버에서 그려서 미리 내려주는 것이 클라이언트에서 HTML을 삽입하는 것보다 빠르다.  
  화면 렌더링이 HTTP 요청에 의존적이거나 렌더링할 HTML 크기가 커진다면 서버 사이드 렌더링이 빠를 수 있다.

- 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.

  <details>
  <summary>검색 엔진이 사이트 정보를 가져가는 과정</summary>

  <ol>
  <li>검색 엔진 로봇(머신)이 페이지에 진입한다.</li>
  <li>페이지가 HTML 정보를 제공해 로봇이 이 HTML을 다운로드한다. (자바스크립트 코드 실행 X)</li>
  <li>다운로드한 HTML 페이지 내부의 오픈 그래프(Open Graph)나 메타(meta) 태그 정보를 기반으로 페이지의 검색(공유)정보를 가져오고 검색엔진에 저장한다.</li>
  </ol>
  </details>

  CSR은 검색엔진이나 SNS 공유 시에 불이익이 있을 수 있지만,  
  서버 사이드 렌더링은 검색 엔진에 제공할 정보를 서버에서 가공해서 HTML 응답으로 제공하므로 검색 엔진 최적화가 용이하다.

- 누적 레이아웃 이동(Cumulative Layout Shift)이 적다.

  누적 레이아웃 이동 : 사용자에게 페이지를 보여준 이후에 뒤늦게 HTML이 변경되어 화면이 덜컥거리는 부정적인 사용자 경험  
  SPA에서는 API의 응답 속도가 제각각이므로 적절한 처리가 없다면 누적 레이아웃 이동 문제가 발생할 수 있다.  
  SSR에서는 모든 요청이 완료된 이후에 페이지가 제공되므로 이 문제에 비교적 자유롭다.

  > 이 문제는 리액트 18에서 등장한 스트림으로 인해 해결 될 수도(?) 있다. ~~뒤에서~~

- 사용자의 디바이스 성능에 비교적 자유롭다.

  자바스크립트 리소스 실행 부담을 서버에 나눌 수 있으므로 사용자 디바이스 성능에 조금 더 자유로워질 수 있다.

- 보안에 좀 더 안전하다.

  JAM 스택은 애플리케이션의 모든 활동이 브라우저에 노출되므로 민감한 정보(API 호출, 인증)가 파악될 수 있다.  
  서버 사이드 렌더링은 인증 혹은 민감한 작업을 서버에서 수행하여 보안 위협을 피할 수 있다.

**단점**

- 소스코드를 작성할 때 항상 서버를 고려해야 한다.

  브라우저 전역 객체인 `window`나 `sessionStorage`를 사용할 수 없다.  
  외부 라이브러리 역시 서버에 대한 고려가 되어있지 않다면 클라이언트에서만 실행되도록 처리해야 한다.

- 적절한 서버가 구축돼 있어야 한다.

  사용자의 요청을 받아 렌더링을 수행할 **적절한** 서버가 필요하다.  
  물리적인 가용량 확보, 장애 대응 전략, 요청 분산, 프로세스 매니저 등 ...

- 서비스 지연에 따른 문제
  SPA에서 느린 작업이 실행 될 경우 -> 로딩 스피너 등 안내 요소를 삽입 할 수 있다.  
  SSR에서 최초 페이지에 지연이 일어나면 사용자에 그 어떤 정보도 제공할 수 없다.  
  결과적으로 더 안 좋은 사용자 경험을 제공할 수도 있다.

### 4.1.3 SPA와 SSR을 모두 알아야 하는 이유

#### 서버 사이드 렌더링 역시 만능이 아니다.

> 설계가 잘못됐다면 관리 포인트만 두개가 되는 역효과가 생긴다.  
> 웹페이지의 설계와 목적, 우선순위에 따라 선택해야 한다.

#### 싱글 페이지 애플리케이션과 서버 사이드 렌더링 애플리케이션

- [가장 뛰어난 싱글 페이지 애플리케이션은 가장 뛰어난 멀티 페이지 애플리케이션보다 낫다.](https://x.com/Rich_Harris/status/1539084063558062080)

  최적화 잘 된 한 싱글 페이지 애플리케이션 하나 열 멀티 페이지 애플리케이션 안 부럽다.

- 평균적인 싱글 페이지 애플리케이션은 평균적인 멀티 페이지 애플리케이션보다 느리다.

  싱글 페이지 애플리케이션을 최적화 하는 작업은 매우 어렵고 노력이 많이 든다.  
  같은 노력이라면 서버에서 렌더링되는 멀티 페이지 애플리케이션이 더 우위에 있을 수 있다.  
  최근에는 멀티 페이지 애플리케이션에서 발생하는 라우팅 문제를 해결하기 위한 API가 브라우저에 추가되고 있다.

  - [페인트 홀딩(Paint Holding)](https://developer.chrome.com/blog/paint-holding?hl=ko) : 같은 출처(origin)에서 라우팅이 일어날 경우 화면을 잠깐 하얗게 띄우는 대신 이전 페이지의 모습을 잠깐 보여주는 기법
  - [back forward cache(bfcache)](https://web.dev/articles/bfcache?hl=ko) : 브라우저 앞으로 가기, 뒤로가기 실행 시 캐시된 페이지를 보여주는 기법
  - Shared Element Transitions : 페이지 라우팅이 일어났을 때 두 페이지에 동일 요소가 있다면 해당 콘텍스트를 유지해 부드럽게 전환되게 하는 기법

#### 현대의 서버 사이드 렌더링

요즘의 서버 사이드 렌더링은 LAMP 스택과 싱글 페이지 렌더링의 장점을 모두 취한 방식으로 작동한다.

1. 최초 웹사이트 진입 시 서버 사이드 렌더링 방식으로 서버에서 완성된 HTML을 제공받는다.
2. 이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 SPA처럼 작동한다.

> 서버에서의 렌더링, 클라이언트에서의 렌더링을 모두 이해해야 두 가지 장점을 완벽하게 취하는 제대로 된 웹서비스를 구현할 수 있다.  
> _그렇지 않다면 LAMP 스택처럼 모든 페이지에서 SSR로 작동하거나, 서버가 아무일도 안하는 SSR의 탈을 쓴 SPA를 만들어 버릴 수도 있다..._

## 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기

react-dom/server.js 에서 react-dom이 서버에서 렌더링하기 위한 다양한 메서드를 제공하고 있으며, server.node.js에 있는 함수를 export하고 있다.  
어떤 함수가 무슨 역할을 하는지 하나씩 살펴보자. *리액트 18이 릴리스되며 추가된 함수나 지원 중단된 사항은 나중에 다뤄보자.*

### 4.2.1 renderToString

인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수

```tsx
import ReactDOMServer from "react-dom/server";

function ChildrenComponent({ fruits }: { fruits: Array<string> }) {
  useEffect(() => {
    console.log(fruits);
  }, [fruits]);

  function handleClick() {
    console.log("hello");
  }

  return (
    <ul>
      {fruits.map((fruit) => (
        <li key={fruit} onClick={handleClick}>
          {fruit}
        </li>
      ))}
    </ul>
  );
}

function SampleComponent() {
  return (
    <>
      <div>hello</div>
      <ChildrenComponent fruits={["apple", "banana", "peach"]} />
    </>
  );
}

const result = ReactDOMServer.renderToString(React.createElement("div", { id: "root" }, <SampleComponent />));
```

위 result는 다음과 같은 문자열을 반환한다.

```html
<div id="root" data-reactroot="">
  <div>hello</div>
  <ul>
    <li>apple</li>
    <li>banana</li>
    <li>peach</li>
  </ul>
</div>
```

`useEffect`와 같은 훅과 `handleclick`과 같은 이벤트 핸들러는 결과물에 포함되지 않았다.  
`renderToString`은 주어진 리액트 컴포넌트를 기준으로 **빠르게 렌더링 할 HTML**을 제공하는 데 목적이 있는 함수일 뿐이다.

클라이언트에서 실행되는 자바스크립트 코드를 포함하거나 렌더링해주지 않으므로 자바스크립트 코드는 별도로 브라우저에 제공되어야 하고, 사용자 인터랙션을 위해서는 자바스크립트 코드를 다운로드, 파싱, 실행하는 과정이 필요하다.

`renderToString`은 완성된 HTML을 서버에서 제공할 수 있으므로

- 초기 렌더링에서 뛰어나 성능을 보일 수 있다.
- 검색 엔진이나 SNS 공유를 위한 메타 정보도 준비한 채로 제공할 수 있다.

`div#root`에 존재하는 `data-reactroot`는 리액트 컴포넌트의 루트 엘리먼트를 식별하고, 자바스크립트를 실행하기 위한 `hydrate`함수에서 루트를 식별하는 기준점이 된다.

### 4.2.2. renderToStaticMarkup

> data-reactroot 같은 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않고 HTML 문자열을 만든다.

```tsx
// 이하 생략
const result = ReactDOMServer.renderToString(React.createElement("div", { id: "root" }, <SampleComponent />));

<div id="root">
  <div>hello</div>
  <ul>
    <li>apple</li>
    <li>banana</li>
    <li>peach</li>
  </ul>
</div>;
```

이 함수 결과로 렌더링을 수행하면 클라이언트는 리액트에서 제공하는 useEffect와 같은 브라우저API를 절대로 실행할 수 없다.

> 💡 리액트의 이벤트 리스너가 필요없는 정적 페이지를 만들때만 사용하자.

### 4.2.3 renderToNodeStream

`renderToNodeStream`은 `renderToString`과 결과물이 완전히 동일하지만, 두 가지 차이점이 있다.

- `renderToNodeStream`은 브라우저에서 사용하는 것이 완전히 불가능하다. (이전 두가지는 브라우저에서도 실행할 수는 있다.)

  `renderToNodeStream`을 브라우저에서 사용하면 아래 에러가 발생한다.

  ```text
  ReactDOMServer.renderToNodeStram(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.
  ```

  완전히 Node.js 환경에 의존하고 있다는 사실을 알 수 있다.

- 결과물을 `Node.js Readable Stream`으로 렌더링한다.  
  `ReadableStream`: utf-8로 인코딩 된 바이트 스트림으로, Node.js나 Deno, Bun 같은 서버 환경에서만 사용할 수 있다.  
  결국, 브라우저에 렌더링 할 string을 얻기 위해서는 추가적인 처리가 필요하다.

이 메서드는 스트림 방식을 사용해서 HTML을 청크 단위로 분리하여 순차적으로 처리하고 HTML 응답을 청크 단위로 작성하는 메서드이다.
따라서 생성할 HTML의 크기가 매우 클 때 사용할 수 있다.

<br>
<details>
<summary>그런데...</summary>

![image](https://github.com/fe-deep-dive/study-react-deep-dive/assets/55120738/29a68340-47b2-4427-aed7-c6d52a694f67)

![image](https://github.com/fe-deep-dive/study-react-deep-dive/assets/55120738/116ff239-759a-4205-8373-8a85d3fbe356)

리액트18로 올라오면서 기존 메소드가 성능도 좋지 않고, 잘 사용되지도 않고, stream을 더 이상 수행하지 않으므로 `renderToPipeableStream`을 사용하라고 한다. [PR](https://github.com/reactwg/react-18/discussions/22)

</details>
<br>

### 4.2.4. renderToStaticNodeStream

`renderToNodeStream`의 결과물에 자바스크립트에 필요한 리액트 속성이 제공되지 않는, hydrate가 필요없는 순수 HTML이 필요할 때 사용하는 메서드지만...  
React 공식문서에는 표시가 없지만 이 역시 React 18부터 Deprecated 되었으므로 사용하지 않는 것을 권장한다.
