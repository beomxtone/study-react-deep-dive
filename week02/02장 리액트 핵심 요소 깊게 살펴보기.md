# 02장 리액트 핵심 요소 깊게 살펴보기

## 2.1 JSX란?

JSX는 XML과 유사한 내장형 구문이며, 리액트에 종속적이지 않은 독자적인 문법이다.

페이스북에서 독자적으로 개발한 구문으로, XML 스타일의 트리 구문을 트랜스파일이라는 과정을 거쳐 자바스크립트(ECMAScript)가 이해할 수 있는 코드로 변경하는 데 도움을 주는 문법이다.

### 2.1.1 JSX의 정의

JSX는 기본적으로 JSXElement, JSXAttributes, JSXChildren, JSXStrings라는 4가지 컴포넌트를 기반으로 구성돼 있다.

**JSXElement**

JSX를 구성하는 가장 기본 요소로, HTML의 요소(element)와 비슷한 역할을 한다. JSXElement가 되기 위해서는 다음과 같은 형태 중 하나여야 한다.

- JSXOpeningElment: JSXOpeningElement로 시작했다면 후술할 JSXClosingElement가 동일한 요소로 같은 단계에서 선언돼 있어야 올바른 JSX 문법으로 간주된다.
  - 예: `<JSXElement JSXAttributes(optional)>`
- JSXClosingElement: JSXOpeningElement가 종료됐음을 알리는 요소로, 반드시 JSXOpeningElement와 쌍으로 사용돼야 한다.
  - 예: `</JSXElement>`
- JSXSelfClosingElement: 요소가 시작되고, 스스로 종료되는 형태를 의미한다. <script/>와 동일한 모습을 띠고 있다. 이는 내부적으로 자식을 포함할 수 없는 형태를 의미한다.
  - 예: `<JSXElement JSXAttributes(optional) />`
- JSXFragment: 아무런 요소가 없는 형태로, JSXSelfClosingElement 형태를 띨 수는 없다. </>는 불가능하다. 단 <></>는 가능하다.
  - 예: `<>JSXChildren(optional)</>`
 

JSXElementName

- JSXIdentifier: JSX 내부에서 사용할 수 있는 식별자를 의미한다. 자바스크립트 식별자 규칙과 동일하다. 즉, 숫자로 시작하거나 $와 _ 이외의 다른 특수문자로 시작할 수 없다.
- JSXNamespacedName: `JSXIdentifier: JSXIdentifier`의 조합, 즉 :을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급된다. :로 묶을 수 있는 것은 한 개뿐이다. 두 개 이상은 올바른 식별자로 취급되지 않는다.
- JSXMemberExpression: `JSXIdentifier.JSXIdentifier`의 조합, 즉 .을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자고 취급된다. :로 묶는 JSXNamespacedName과는 다르게 .을 여러 개 이어서 하는 것도 가능하다. 단 JSXNamespacedName과 이어서 사용하는 것은 불가능하다.

> 리액트에서 HTML 구문 이외에 사용자가 컴포넌트를 만들어 사용할 때에는 반드시 대문자로 시작하는 컴포넌트를 만들어야만 사용 가능하다. 이는 JSXElement 표준에는 없는 내용인데, 그 이유는 리액트에서 HTML 태그명과 사용자가 만든 컴포넌트 명을 구분 짓기 위해서다.

**JSXAttributes**

JSXElement에 부여할 수 있는 속성을 의미한다. 단순히 속성을 의미하기 때문에 모든 경우에서 필수값이 아니고, 존재하지 않아도 에러가 나지 않는다.

- JSXSpreadAttributes: 자바스크립트에서의 전개 연산자와 동일한 역할을 한다고 볼 수 있다.
  - `{...AssignmentExpression}`: 이 AssignmentExpression에는 단순히 객체뿐만 아니라 자바스크립트에서 AssignmentExpression으로 취급되는 모든 표현식이 존재할 수 있다. 여기에는 조건문 표현식, 화살표 함수, 할당식 등 다양한 것이 포함돼 있다.
- JSXAttribute: 속성을 나타내는 키와 값으로 짝을 이루어서 표현한다. 키는 JSXAttributeName, 값은 JSXAttributeValue로 불린다.
  - JSXAttributeName: 속성의 키 값. 키로는 앞서 JSXElementName에서 언급했던 JSXIdentifier와 JSXNamespacedNamem이 가능하다. 여기서도 마찬가지로 :을 이용해 키를 나타낼 수 있다.
    ```jsx
    function valid1() {
      return <foo.bar foo:bar="baz"></foo.bar>
    }
    ```
  - JSXAtributeValue: 속성의 키에 할당할 수 있는 값으로, 다음 중 하나를 만족해야 한다.
    - `"큰따옴표로 구성된 문자열"`: 자바스크립트의 문자열과 동일하다. 안에 아무런 내용이 없어도 상관없다.
    - `'작은따옴표로 구성된 문자열'`: 자바스크립트의 문자열과 동일하다. 안에 아무런 내용이 없어도 상관없다.
    - `{ AssignmentExpression }`: 자바스크립트의 AssignmentExpression을 의미한다. AssignmentExpression은 자바스크립트에서 값을 할당할 때 쓰는 표현식을 말한다. 즉, 자바스크립트에서 변수에 값을 넣을 수 있는 표현식은 JSX 속성의 값으로도 가능하다.
    - JSXElement: 값으로 다른 JSX 요소가 들어갈 수 있다. 리액트에서 자주 볼 수 없는 코드지만 다음과 같은 형태도 가능하다.
    - JSXFragment: 값으로 별로 속성을 갖지 않는 형태의 JSX 요소가 들어갈 수 있다.

**JSXChildren**

JSXElement의 자식 값을 나타낸다. JSX는 앞서 언급했듯 속성을 가진 트리 구조를 나타내기 위해 만들어졌기 때문에 JSX로 부모와 자식 관계를 나타낼 수 있으며, 그 자식을 JSXChildren이라고 한다.

- JSXChild: JSXChildren을 이루는 기본 단위다. 단어의 차이에서 알 수 있듯이 JSXChildren은 JSXChild를 0개 이상 가질 수 있다.
  - JSXText: {, <, >, }을 제외한 문자열. 이는 다른 JSX 문법과 혼동을 줄 수 있기 대문이다. 만약 이 문자를 표현하고 싶다면 문자열로 표시하는 방법이 있다.
    ```jsx
    function valid() {
      return <>{'{} <>'}</>
    }
    ```
  - JSXElement: 값으로 다른 JSX 요소가 들어갈 수 있다.
  - JSXFragment: 값으로 빈 JSX 요소인 <></>가 들어갈 수 있다.
  - { JSXChildExpression (optional) }: 이 JSXChildExpression은 자바스크립트의 AssignmentExpression을 의미한다. 익숙하지 않겠지만 다음과 같은 코드도 올바른 JSX 표현식으로 볼 수 있다.
    ```jsx
    // 이 함수를 리액트에서 렌더링하면 "foo"라는 문자열이 출력된다.
    export default function App() {
      return <>{(() => 'foo')()}</>
    }
    ```

**JSXStrings**

앞서 소개한 JSXAttributeValue와 JSXText는 HTML과 JSX 사이에 복사와 붙여넣기를 쉽게 할 수 있도록 설계돼 있다. HTML에서 사용 가능한 문자열은 모두 JSXStrings에서도 가능하다. 여기서 정의된 문자열이라 함은, "큰따옴표로 구성된 문자열", '작은따옴표로 구성된 문자열', 혹은 JSXText를 의미한다.

자바스크립트와 한 가지 중요한 차이점이 발생하는데 바로 \로 시작하는 이스케이프 문자 형태소다. \는 자바스크립트에서 특수문자를 처리할 때 사요되므로 몇 가지 제약사항이 있지만 HTML에서는 아무런 제약 없이 사용할 수 있다.

### 2.1.2 JSX 예제

```jsx
// 하나의 요소로 구성된 가장 단순한 형태
const ComponentA = <A>방가방가</A>

// 자식없이 SelfClosingTag로 닫혀 있는 형태
const Component B = <A />

// 옵션을 { }와 전개 연산자로 넣을 수 있다.
const ComponentC = <A {...{ required: true }} />

// 속성만 넣어도 가능하다.
const ComponentD = <A required />

// 속성과 속성값을 넣을 수 있다.
const ComponentE = <A required={false} />

const ComponentF = (
  <A>
    {/* 문자열은 큰따옴표 및 작은따옴표 모두 가능하다. */}
    <B text="햄토리" />
  </A>
)

const ComponentG = (
  <A>
    {/* 옵션의 값으로 JSXElement를 넣는 것 또한 올바른 문법이다. */}
    <B optionalChildren={<>방가방가</>} />
  </A>
)

const ComponentH = (
  <A>
    {/*여러 개의 자식도 포함할 수 있다. */}
    방가방가
    <B text="햄토리" />
  </A>
)
```

이 외에도 리액트 내에서는 유효하지 않거나 사용되는 경우가 거의 없는 문법도 JSX 문법 자체로는 유효하다.
```jsx
function ComponentA() {
  return <A.B></A.B>
}

function ComponentB() {
  return <A.B.C></A.B.C>
}

function ComponentC() {
  return <A:B.C></A:B.C>
}

function ComponentD() {
  return <$></$>
}
```

### 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?

우선 자바스크립트에서 JSX가 변환되는 방식을 알려면 리액트에서 JSX를 변환하는 @babel/plugin-transform-react-jsx 플러그인을 알아야 한다. 이 플러그인은 JSX 구문을 자바스크립트가 이해할 수 있는 형태로 변환한다.

```jsx
const ComponentA = <A required={true}>방가방가 햄토리</A>

const ComponentB = <>방가방가 햄토리</>

const ComponentC = (
  <div>
    <span>방가방가 햄토리</span>
  </div>
)
```

위의 JSX 코드를 변환한 결과는 다음과 같다.

```jsx
'use strict'

var ComponentA = React.createElement(
  A,
  {
    required: true,
  },
  '방가방가 햄토리',
)
var ComponentB = React.createElement(React.Fragment, null, '방가방가 햄토리')
var ComponentC = React.createElement(
  'div',
  null,
  React.createElement('span', null, '방가방가 햄토리'),
)
```

리액트 17, 바벨 7.9.0 이후 버전에서 추가된 자동 런타임으로 트랜스타일한 결과는 다음과 같다. (두 결과의 자세한 차이점은 8장에서 설명한다.)

```jsx
'use strict'

var _jsxRuntime = require('custom-jsx-library/jsx-runtime')

var ComponentA = (0, _jsxRuntime.jsx)(A, {
  required: true,
  children: '방가방가 햄토리',
})
var ComponentB = (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
  children: '방가방가 햄토리',
})
var ComponentC = (0, _jsxRuntime.jsx)('div', {
  children: (0, _jsxRuntime.jsx)('span', {
    children: '방가방가 햄토리',
  }),
})
```

@babel/plugin-transform-react-jsx를 직접 써보고 싶다면 필요한 패키지를 설치하고 다음과 같이 코드를 작성하면 된다.

**직접 해보기**

```jsx
import * as Babel from '@babel/standalone'

Babel.registerPlugin(
  '@babel/plugin-transform-react-jsx',
  require('@babel/plugin-transform-react-jsx'),
)

const BABEL_CONFIG = {
  presets: [],
  plugins: [
    [
      '@babel/plugin-transform-react-jsx',
      {
        throwIfNamespace: false,
        runtime: 'automatic',
        importSource: 'custom-jsx-library',
      },
    ],
  ],
}

const SOURCE_CODE = `const ComponentA = <A>'방가방가 햄토리'</A>`
// code 변수에 트랜스파일된 결과가 담긴다.
const { code } = Babel.transform(SOURCE_CODE, BABEL_CONFIG)
```

두 결과물에 약간의 차이가 있지만 다음가 같은 공통점이 있다.

- JSXElement를 첫 번째 인수로 선언해 요소를 정의한다.
- 옵셔널인 JSXChildren, JSXAttributes, JSXStrings는 이후 인수로 넘겨주어 처리한다.

이 점을 활용한다면 JSXElement만 다르고, JSXAttributes, JSXChildren이 완전히 동일한 JSXElement를 렌더링해야 할 때 중복 코드를 최소화할 수 있어 유용하다.

```jsx
import { createElement, PropsWithChildren } from 'react'

// ❌ props 여부에 따라 children 요소만 달라지는 경우
// 전체 내용을 삼항 연산자로 처리하여 불필요한 코드 중복이 일어난다.
function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return isHeading ? (
    <h1 className="text">{children}</h1>
  ) : (
    <span className="text>{children}</span>
  )
}

// ⭕ JSX가 변환되는 특성을 활용한다면 다음과 같이 간결하게 처리할 수 있다.
import { createElement } from 'react'

function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return createElement(
    isHeading ? 'h1' : 'span',
    { className: 'text' },
    children,
  )
}
```

JSX 반환값이 결국 React.createElement로 귀결된다는 사실을 파악한다면 이런 식으로 쉽게 리팩터링할 수 있다.

### 2.1.4 정리

JSX 문법에는 있지만 실제로 리액트에서 사요하지 않는 것은 다음과 같다.
- JSXNamespacedName
- JSXMemberExpression

Preact, SolidJS, Nano JSX 등 다양한 라이브러리에서도 JSX를 채용하고 있으며, 이 라이브러리들은 JSXNamespacedName, JSXMemberExpression을 목적에 따라 사용할 수도 있으므로 반드시 이러한 스펙도 JSX 문법임을 알아둬야 한다.

JSX는 자바스크립트 코드 내부에 HTML과 같은 트리 구조를 가진 컴포넌트를 표현할 수 있다는 점에서 각광받고 있다. 그러나 JSX 내부에 자바스크립트 문법이 많아질수록 복잡성이 증대하면서 코드의 가독성도 해칠 것이므로 주의해서 사용해야 한다.

## 2.2 가상 DOM과 리액트 파이버

### 2.2.1 DOM과 브라우저 렌더링 과정

본격적인 DOM의 정의를 다루기에 앞서 먼저 브라우저가 웹사이트 접근 요청을 받고 화면을 그리는 과정에서 정확히 어떠한 일이 일어나는지 살펴보자.

1. 브라우저가 사용자가 요청한 주소를 방문해 **HTML 파일을 다운로드**한다.
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(**DOM**)를 만든다.
3. 2번 과정에서 CSS 파일을 만나면 해당 **CSS 파일도 다운로드**한다.
4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(**CSSOM**)를 만든다.
5. 브라우저는 2번에서 만든 **DOM 노드를 순회**하면서 눈에 보이는 노드만 방문한다. (`display: none`과 같은 요소 제외)
6. 5번에서 제외된, 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 **CSS 스타일 정보를 이 노드에 적용**한다.
  - 레이아웃(layout, reflow): 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정. 이 레이아웃 과정을 거치면 반드시 페인팅 과정도 거치게 된다.
  - 페인팅(painting): 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

### 2.2.2 가상 DOM의 탄생 배경

브라우저가 웹페이지를 렌더링하는 과정은 매우 복잡하고 많은 비용이 든다. 또한 렌더링이 완료된 이후에도 사용자의 인터렉션으로 웹페이지가 변경되는 상황도 고려해야 한다.

특정한 요소의 색상이 변경되는 경우 -> 페인팅만 일어남

특정한 요소의 노출 여부 혹은 사이즈가 변경되는 경우 -> 레이아웃과 리페인팅이 일어남

DOM 변경이 일어나는 요소가 많은 자식 요소를 가지고 있는 경우 -> 하위 자식 요소도 덩달아 변경돼야 하기 때문에 더 많은 비용이 듦

이러한 추가 렌더링 작업은 SPA에서 더욱 많아지고 DOM을 관리하는 과정에서 부담해야 할 비용이 커진다.

DOM 변경을 일으키고 관리하는 개발자의 입장에서 이 상황을 생각해보면, 사용자 인터렉션에 따라 DOM의 모든 변경 사항을 추적하는 것은 너무나 수고스러운 일이기 때문에 최종 결과물을 간편하게 제공하는 것은 브라우저 뿐만 아니라 개발자에게도 매우 유용하다.

이러한 문제점을 해결하기 위해 탄생한 것이 바로 가상 DOM이다. 가상 DOM은 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트(package.json의 react-dom)가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영한다. 이렇게 DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한 번 거치게 된다면 렌더링 과정을 최소화할 수 있고 브라우저와 개발자의 부담을 덜 수 있다.

리액트의 가상 DOM 방식은 일반적인 DOM을 관리하는 브라우저보다 무조건 빠른 것이 아니라 대부분의 상황에서 웬만한 애플리케이션을 만들 수 있을 정도로 충분히 빠른 것이므로 오해하지 말자.

### 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 바로 리액트 파이버<sup>React Fiber</sup>이다.

**리액트 파이버란?**

리액트 파이버는 리액트에서 관리하는 평범한 자바스크립트 객체다. 파이버는 파이버 재조정자<sup>fiber reconciler</sup>가 관리하는데, 이는 앞서 이야기한 가상 DOM과 실제 DOM을 비교해 **변경 사항을 수집**하며, 만약 차이가 있으면 **변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청**한다.

리액트 파이버의 목표는 리액트 웹 애플리케이션에서 발생하는 애니메이션, 레이아웃, 그리고 사용자 인터렉션에 올바른 결과물을 만드는 **반응성 문제를 해결**하는 것이다.

이를 위해 파이버는 다음과 같은 일을 할 수 있다.
- 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
- 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우 폐기할 수 있다.

그리고 한 가지 중요한 것은 이러한 모든 과정이 비동기로 일어난다는 것이다. 기존 자바스크립트의 동기적 방식은 비효율성으로 이어졌고, 리액트 팀은 기존 렌더링 스택의 비효율성을 타파하기 위해 스택 조정자 대신 파이버라는 개념을 탄생시킨다.

파이버는 일단 하나의 작업 단위로 구성돼 있다. 리액트는 이러한 작업 단위를 하나씩 처리하고 finishedWork()라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다. 그리고 이러한 단계는 아래 두 단계로 나눌 수 있다. (2.4절에서 더 자세히 다룬다.)

1. **렌더 단계**에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 그리고 이 단계에서 앞서 언급한 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.
2. **커밋 단계**에서는 앞서 언급한 것처럼 DOM에 실제 변경 사항을 반영하기 위한 작업, commitWork()가 실행되는데, 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수도 없다.

파이버가 실제 리액트 코드에서 어떻게 구현돼 있는지 살펴보자. (리액트 18.2.0 기준)

```jsx
function FiberNode(tag, pendingProps, key, mode) {
  // Instance
  this.tag = tag
  this.key = key
  this.elementType = null
  this.type = null
  this.stateNode = null

  // Fiber
  this.return = null
  this.child = null
  this.sibling = null
  this.index = 0
  this.ref = null
  this.refCleanup = null

  this.pendingProps = pendingProps
  this.memorizedProps = null
  this.updateQueue = null
  this.memorizedState = null
  this.dependencies = null

  this.mode = mode

  // Effects
  this.flags = NoFlags
  this.subtreeFlags = NoFlags
  this.deletions = null

  this.lanes = NoLanes
  this.childLanes = NoLanes

  this.alternate = null

  // 이하 프로파일러, __DEV__ 코드는 생략
}
```

파이버는 단순한 자바스크립트 객체로 구성돼 있는 것을 볼 수 있다. 리액트 요소와 한 가지 중요한 차이점은 리액트 요소는 렌더링이 발생할 때마다 새롭게 생성되지만 파이버는 가급적 재사용된다는 사실이다. 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 재사용된다.

다음은 리액트에 작성돼 있는 파이버를 생성하는 함수이다.

```jsx
var createFiber = function (tag, pendingProps, key, mode) {
  return new FiberNode(tag, pendingProps, key, mode)
}

// 생략...
function createFiberFromElement(element, mode, lanes) {
  var owner = null
  {
    owner = element._owner
  }

  var type = element.type
  var key = element.key
  var pendingProps = element.props
  var fiber = createFiberFromTypeAndProps(
    type,
    key,
    pendingProps,
    owner,
    mode,
    lanes,
  )

  {
    fiber._debugSource = element._source
    fiber._debugOwner = element._owner
  }

  return fiber
}

function createFiberFromFragment(elements, mode, lanes, key) {
  var fiber = createFiber(Fragment, elements, key, mode)
  fiber.lanes = lanes
  return fiber
}
```

함수명에서 알 수 있는 것처럼 앞서 언급한 1:1 관계를 확인해 볼 수 있다.

리액트 파이버에서 선언된 주요 속성을 살펴보자.

- tag: 파이버를 만드는 함수 이름인 createFiberFromFragment를 보면 유추할 수 있겠지만 파이버는 하나의 element에 하나가 생성되는 1:1 관계를 가지고 있다. 여기서 1:1로 매칭된 정보를 가지고 있는 것이 바로 tag다.

  [리액트에 작성돼 있는 파이버의 태그가 가질 수 있는 값들]

  ```jsx
  var FunctionComponent = 0
  var ClassComponent = 1
  var Indeterminatecomponent = 2
  var HostRoot = 3
  var HostPortal = 4
  var HostComponent = 5
  var HostText = 6
  var Fragment = 7
  var Mode = 8
  var ContextConsumer = 9
  var ContextProvider = 10
  var ForwardRef = 11
  var Profiler = 12
  var SuspenseComponent = 13
  var MemoComponent = 14
  var SimpleMemoComponent = 15
  var LazyComponent = 16
  var IncompleteClassComponent = 17
  var DehydratedFragment = 18
  var SuspenseListComponent = 19
  var ScopeComponent = 21
  var OffscreenComponent = 22
  var LegacyHiddenComponent = 23
  var CacheComponent = 24
  var TracingMarkerComponent = 25
  ```

  여기서 HostComponent가 바로 웹의 div와 같은 요소를 의미한다. 이 외에도 FunctionComponent, ClassComponent와 같이 몇 가지 친숙해 보이는 타입이 존재한다.
- stateNode: 이 속성에서는 파이버 자체에 대한 참조(reference) 정보를 가지고 있으며, 이 참조를 바탕으로 리액트는 파이버와 관련된 상태에 접근한다.
- child, sibling, return: 파이버 간의 관계 개념을 나타내는 속성이다. 리액트 컴포넌트 트리가 형성되는 것과 동일하게 파이버도 트리 형식을 갖게 되는데, 이 트리 형식을 구성하는 데 필요한 정보가 이 속성 내부에 정의된다. 리액트 컴포넌트 트리와 다른 점은 children이 없다는 것, 즉 하나의 child만 존재한다는 점이다.

  그렇다면 다음과 같이 여러 개의 자식이 있는 구조는 파이버로 어떻게 표현될까?
  
  ```jsx
  <ul>
    <li>하나</li>
    <li>둘</li>
    <li>셋</li>
  </ul>
  ```
  
  파이버의 자식은 항상 첫 번째 자식의 참조로 구성되므로 `<ul/>` 파이버의 자식은 첫 번째 `<li/>` 파이버가 된다.

  나머지 두 개의 `<li/>` 파이버는 형제, 즉 sibling으로 구성된다.

  마지막으로 return은 부모 파이버를 의미하며, 여기서 모든 `<li/>` 파이버는 `<ul/>` 파이버를 return으로 갖게 될 것이다.
  
- index: 여러 형제들(sibling) 사이에서 자신의 위치가 몇 번째인지 숫자로 표현한다.
- pendingProps: 아직 작업을 미처 처리하지 못한 props
- memorizedProps: pendingProps를 기준으로 렌더링이 완료된 이후에 pendingProps를 memorizedProps로 저장해 관리한다.
- updateQueue: 상태 업데이트, 콜백 함수, DOM 업데이트 등 필요한 작업을 담아두는 큐. 이 큐는 대략 다음과 같은 구조를 가지고 있다.
  ```jsx
  type UpdateQueue = {
    first: Update | null
    last: Update | null
    hasForceUpdate: boolean
    callbackList: null | Array<Callback> //setState로 넘긴 콜백 목록
  }
  ```
- memorizedState: 함수 컴포넌트의 훅 목록이 저장된다. 여기에는 단순히 useState뿐만 아니라 모든 훅 리스트가 저장된다.
- alternate: 뒤이어 설명할 리액트 파이버 트리와 이어질 개념. 리액트의 트리는 두 개인데, 이 alternate는 반대편 트리 파이버를 가리킨다.

이렇게 생성된 파이버는 **state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행**된다. 그리고 중요한 것은 리액트가 파이버를 처리할 때 작업을 작은 단위로 나눠서 처리하거나 **우선순위를 스케줄링 하는 등 유연하게 처리**한다는 것이다.

리액트 개발 팀은 사실 리액트는 가장 DOM이 아닌 Value UI, 즉 값을 가지고 있는 UI를 관리하는 라이브러리라는 내용을 피력한 바 있다. 리액트의 핵심 원칙은 **UI를** 문자열, 숫자, 배열과 같은 **값으로 관리**한다는 것이다. 변수에 이러한 UI 관련 값을 보관하고, 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고 표현하는 것이 바로 리액트다.

**리액트 파이버 트리**

파이버 트리는 리액트 내부에서 두 개가 존재한다.

하나는 **현재 모습을 담은 파이버 트리**이고, 다른 하나는 작업 중인 상태를 나타내는 **workInProgress 트리**다.

리액트 파이버의 작업이 끝나면 리액트는 **단순히 포인터만 변경**해 workInProgress 트리를 현재 트리로 바꿔버린다. 이러한 기술을 **더블 버퍼링**이라고 한다.

<p align="center"><img src="https://github.com/parkyolo/study-react-deep-dive/assets/39394642/b25b1093-125f-411d-959f-152bfd5791da"></p>

더블 버퍼링을 위해 트리가 두 개 존재하며, 이 더블 버퍼링은 커밋 단계에서 수행된다.

즉, 먼저 현재 UI 렌더링을 위해 존재하는 트리인 Current Tree를 기준으로 모든 작업이 시작된다. 여기에서 만약 업데이트가 발생하면 파이버는 리액트에서 새로 받은 데이터로 새로운 WorkInProgress Tree를 빌드하기 시작한다.

이 WorkInProgress Tree를 빌드하는 작업이 끝나면 다음 렌더링에 이 트리를 사용한다. 그리고 이 WorkInProgress Tree가 UI에 최종적으로 렌더링되어 반영이 완료되면 Current Tree가 이 WorkInProgress Tree로 변경된다.

**파이버의 작업 순서**

일반적인 파이버 노드의 생성 흐름은 다음과 같다.

1. 리액트는 beginWork() 함수를 실행해 파이버 작업을 수행하는데, 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.
2. 1번에서 작업이 끝난다면 그다음 completeWork() 함수를 실행해 파이버 작업을 완료한다.
3. 형제가 있다면 형제로 넘어간다.
4. 2번, 3번이 모두 끝났다면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.

위 과정으로 트리가 생성되고, setState 등으로 업데이트가 발생하면 어떻게 될까?

이미 리액트는 앞서 만든 Current Tree가 존재하고, setState로 인해 업데이트 요청을 받아 WorkInProgress Tree를 다시 빌드하기 시작한다.

최초 렌더링 시에는 모든 파이버를 새롭게 만들어야 했지만, 이제는 파이버가 이미 존재하므로 되도록 새로 생성하지 않고 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리한다.

이 트리 업데이트 과정을 과거에는 동기식으로 처리했으나 현재는 우선순위가 높은 다른 업데이트가 오면 현재 업데이트 작업을 일시 중단하거나 새롭게 만들거나, 폐기할 수도 있다. 또한 작업 단위를 나누어 우선순위를 할당하는 것 또한 가능하다. 리액트는 이러한 작업을 파이버 단위로 나눠서 수행한다.

애니메이션이나 사용자가 입력하는 작업은 우선순위가 높은 작업으로 분리하거나, 목록을 렌더링하는 등의 작업은 우선순위가 낮은 작업으로 분리해 최적의 순위로 작업을 완료할 수 있게끔 만든다.

### 2.2.4 파이버와 가상 DOM

앞서 언급했듯이 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이 파이버이며, 이 파이버는 리액트 아키텍처 내부에서 비동기로 이뤄진다.

이러한 비동기 작업과 달리 실제 브라우저 구조인 DOM에 반영하는 것은 동기적으로 일어나야 하고, 또 처리하는 작업이 많아 화면에 불완전하게 표시될 수 있는 가능성이 높으므로 이러한 작업을 가상에서, 즉 메모리 상에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것이 가상 DOM이다.

가상 DOM이라는 표현은 오직 웹 애플리케이션에서만 통용되는 개념이다. 리액트 파이버는 리액트 네이티브와 같은 브라우저가 아닌 환경에서도 사용할 수 있기 때문에 파이버와 가상 DOM은 동일한 개념이 아니다.

리액트와 리액트 네이티브의 렌더러가 서로 다르다 하더라도 내부적으로 파이버를 통해서 조정되는 과정은 동일하기 때문에 동일한 재조정자를 사용할 수 있게 된다.

### 2.2.5 정리

가상 DOM과 파이버는 단순히 브라우저에 DOM을 변경하는 것보다 빠르다는 이유로만 만들어진 것은 아니다.

리액트 내부의 파이버와 재조정자가 내부적인 알고리즘을 통해 관리해 줌으로써 대규모 웹 애플리케이션을 효율적으로 유지보수하고 관리할 수 있게 된 것이다.

가상 DOM과 리액트의 핵심은 브라우저의 DOM을 더욱 빠르게 그리고 반영하는 것이 아니라 바로 값으로 UI를 표현하는 것이다. 화면에 표시되는 UI를 자바스크립트의 문자열, 배열 등과 마찬가지로 값으로 관리하고 이러한 흐름을 효율적으로 관리하기 위한 매커니즘이 바로 리액트의 핵심이다.

## 2.3 클래스 컴포넌트와 함수 컴포넌트

### 2.3.1 클래스 컴포넌트

```jsx
import React from 'react'

class SampleComponent extends React.Component {
  render() {
    return <h2>Sample Component</h2>
  }
)
```

기본적으로 클래스 컴포넌트를 만들려면 클래스를 선언하고 extends로 만들고 싶은 컴포넌트를 extends해야한다. extends 구문에 넣을 수 있는 클래스는 다음과 같다.
- React.component
- React.PureComponent

컴포넌트를 만들 때 주로 쓰이는 props, state, 그리고 메서드는 다음과 같이 정의한다.
```jsx
import React from 'react'

// props 타입을 선언한다.
interface SampleProps {
  required?: boolean
  text: string
}

// state 타입을 선언한다.
interface SampleState {
  count: number
  isLimited?: boolean
}

// Component에 제네릭으로 props, state를 순서대로 넣어준다.
class SampleComponent extends React.Component<SampleProps, SampleState> {
  // constructor에서 props를 넘겨주고, state의 기본값을 설정한다.
  private constructor(props: SampleProps) {
    super(props)
    this.state = {
      count: 0,
      isLimited: false,
    }
  }

  // render 내부에서 쓰일 함수를 선언한다.
  private handleClick = () => {
    const newValue = this.state.count + 1
    this.setState({ count: newValue, isLimited: newValue >= 10 })
  }

  // render에서 이 컴포넌트가 렌더링할 내용을 정의한다.
  public render() {
    // props와 state 값을 this, 즉 해당 클래스에서 꺼낸다.
    const {
      props: { required, text },
      state: { count, isLimited },
    } = this

    return (
      <h2>
        Sample Component
        <div>{required ? '필수' : '필수아님'}</div>
        <div>문자: {text}</div>
        <div>count: {count}</div>
        <button onClick={this.handleClick} disabled={isLimited}>
          증가
        </button>
      </h2>
    )
  }
}
```
- constructor(): 컴포넌트 내부에 이 생성자 함수가 있다면 컴포넌트가 초기화되는 시점에 호출된다. 여기서는 컴포넌트의 state를 초기화할 수 있다. 그리고 여기에 선언돼 있는 super()는 컴포넌트를 만들면서 상속받은 상위 컴포넌트, 즉 React.Component의 생성자 함수를 먼저 호출해 필요한 상위 컴포넌트에 접근할 수 있게 도와준다.
  ```jsx
  import { Component } from 'react'

  class SampleComponent2 extends Component {
    state = {
      count: 1,
    }

    render() {
      const {
        state: { count },
      } = this
      return <div>{count}</div>
    }
  }
  ```
  위와 같이 constructor없이 state를 초기화한 코드는 ES2022에 추가된 클래스 필드 덕분에 가능한 문법이다.

  이 문법은 ES2022 환경을 지원하는 브라우저에서만 코드를 제공하거나 바벨의 @babel/plugin-proposal-class-properties를 사용해 트랜스파일을 거쳐야 한다.
- props: 함수에 인수를 넣는 것과 비슷하게, 컴포넌트에 특정 속성을 전달하는 용도로 쓰인다. 위 예제에서는 props가 `{ required?: boolean; text: string; }`의 형태로 선언되어 있으므로 해당 컴포넌트 호출하기 위해서는 `<SampleComponent text="안녕하세요" />`와 같은 형태로 선언해야 한다.
- state: 클래스 컴포넌트 내부에서 관리하는 값을 의미한다. 이 값은 항상 객체여야 한다. 이 값에 변화가 있을 때마다 리렌더링이 발생한다.
- 메서드: 렌더링 함수 내부에서 사용되는 함수이며, 보통 DOM에서 발생하는 이벤트와 함께 사용된다. 메서드를 만드는 방식은 크게 3가지로 나뉜다.
  - constructor에서 this 바인드를 하는 방법: 생성자가 아닌 일반적인 함수로 메서드를 만든다면 this에 전역 객체가 바인딩되기 때문에 undefined로 나오는 현상을 겪게 될 것이다. 따라서 생성된 함수에 bind를 활용해 강제로 this를 바인딩해야 한다.
    ```jsx
    import { Component } from 'react'

    // 빈 props를 선언
    type Props = Record<string, never>

    interface State {
      count: number
    }

    class SampleComponent extends Component<Props, State> {
      private constructor(props: Props) {
        super(props)
        this.state = {
          count: 1,
        }
        // handleClick의 this를 현재 클래스로 바인딩한다.
        this.handleClick = this.handleClick.bind(this)
      }

      private handleClick() {
        this.setState((prev) => ({ count: prev.count + 1}))
      }

      public render() {
        const {
          state: { count },
        } = this
        return (
          <div>
            <button onClick={this.handleClick}>증가</button>
          </div>
        )
      }
    }
    ```
  - 렌더링 함수 내부에서 함수를 새롭게 만들어 전달하는 방법: `<button onClick={() => this.handleClick()}>증가</button>`
    
    그러나 이 방법을 사용하게 되면 매번 렌더링이 일어날 때마다 새로운 함수를 생성해서 할당하게 되므로 최적화를 수행하기가 매우 어려워진다. 따라서 이 방법은 지양하는 것이 좋다.

**클래스 컴포넌트의 생명주기 메서드**

생명주기 메서드가 실행되는 시점은 크게 3가지로 나눌 수 있다.

- 마운트(mount): 컴포넌트가 마운팅(생성)되는 시점
- 업데이트(update): 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
- 언마운트(unmount): 컴포넌트가 더 이상 존재하지 않는 시점

이 세 가지 시점을 염두에 두고 각 생명주기 메서드를 살펴보자.

render()

이 함수는 컴포넌트가 UI를 렌더링하기 위해서 쓰인다. 그리고 이 렌더링은 **마운트와 업데이트** 과정에서 일어난다.

한 가지 주의할 것은 이 render() 함수는 **항상 순수**해야 하며 부수 효과가 없어야 한다는 것이다. 이 말인즉슨, 같은 입력값(props 또는 state)이 들어가면 항상 같은 결과물을 반환해야 핟나는 뜻이다. 따라서 **render() 내부에서** state를 직접 업데이트하는 **this.setState를 호출해서는 안된다.**

componentDidMount()

클래스 컴포넌트가 마운트되고 준비가 됐다면 그다음으로 호출되는 생명주기 메서드가 바로 componentDidMount()다. 이 함수 내부에서는 this.setState()로 state 값을 변경하는 것이 가능하다. this.setState를 호출했다면 state가 변경되고, 그리고 그 즉시 다시 한번 렌더링을 시도하는데, 이 작업은 브라우저가 실제로 UI를 업데이트하기 전에 실행되어 사용자가 변경되는 것을 눈치챌 수 없게 만든다.

componentDidUpdate()

componentDidUpdate()는 **컴포넌트 업데이트가 일어난 이후 바로** 실행된다. 일반적으로 state나 props의 변화에 따라 DOM을 업데이트하는 등에 쓰인다. 여기서도 this.setState를 사용할 수 있다. 그러나 적절한 조건문으로 감싸지 않는다면 this.setState가 계속해서 호출되는 일이 발생할 수 있다.

componentWillUnmount()

이 생명주기 메서드는 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출되다. 메모리 누수나 불필요한 작동을 막기 위한 **클린업 함수**를 호출하기 위한 최적의 위치다. 이 메서드 내에서는 this.setState를 호출할 수 없다. 이벤트를 지우거나, API 호출을 취소하거나, setInterval, setTimeout으로 생성된 타이머를 지우는 등의 작업을 하는 데 유용하다.
