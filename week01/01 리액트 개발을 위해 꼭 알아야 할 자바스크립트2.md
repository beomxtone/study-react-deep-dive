# 01 리액트 개발을 위해 꼭 알아야 할 자바스크립트2

## 1.4 클로저
클로저를 통해 함수 컴포넌트를 이해할 수 있다. 함수 컴포넌트의 구조와 작동 방식, 훅의 원리, 의존성 배열 등 함수 컴포넌트의 대부분의 기술이 모두 클로저에 의존하고 있어 클로저에 대한 이해는 필수이다.

### 1.4.1 클로저의 정의

클로저는 함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합이다.

**어휘적 환경이란?**

```jsx
function add() {
  const a = 10;
  function innerAdd() {
    const b = 20;
    console.log(a + b);
  }
}
```

변수의 유효 범위는 코드가 작성된 순간에 정적으로 결정되므로 innerAdd는 add 내부에서 선언돼 있어 a를 사용할 수 있다. 여기서 "선언된 어휘적 환경"은 변수가 코드 내부에서 어디서 선언됐는지를 말하는 것이다. 클로저는 이러한 어휘적 환경을 조합해 코딩하는 기법이다.

### 1.4.2 변수의 유효 범위, 스코프 
변수의 유효 범위를 스코프라고 한다.

**전역 스코프**

브라우저 환경에서 window, Node.js 환경에서 global이 있다. 전역 레벨에 선언하면 이 객체에 스코프가 바인딩 된다.

**함수 스코프**

자바스크립트는 기본적으로 함수 레벨 스코프를 따른다. 즉 {} 블록이 스코프 범위를 정하지 않는다.

### 1.4.3 클로저의 활용

**클로저의 활용**

```jsx
function Counter() {
  var counter = 0;
  return {
    increase: function () {
      return ++counter;
    },
    decrease: function () {
      return --counter;
    },
    counter: function () {
      console.log(' counter에 접근!');
      return counter;
    },
  };
}
var c = Counter();

console.log(c.increase()); // 1
console.log(c.increase()); // 2
console.log(c.increase()); // 3
console.log(c.decrease()); // 2
console.log(c.counter()); // 2
```
클로저를 이용했을 때의 장점:
- counter 변수를 직접적으로 노출하지 않음으로써 사용자가 직접 수정하는 것을 막는다.
- 변수의 업데이트를 increase와 decrease로 제한해 무분별하게 변경되는 것을 막는다.

클로저를 활용하면 전역 스코프의 사용을 막고, 개발자가 원하는 정보만 개발자가 원하는 방향으로 노출시킬 수 있다.

**리액트에서의 클로저**

클로저의 원리를 사용하고 있는 대표적인 것 중 하나가 useState이다. 클로저를 이용해 리액트가 관리하는 내부 상태 값은 리액트가 별도로 관리하는 클로저 내부에서만 접근할 수 있다.

```jsx
function Component() {
  const [state, setState] = useState();

  function handleClick() {
    // usestate 호출은 위에서 끝났지만,
    // setstate는 계속 내부의 최신값(prev)을 알고 있다.
    // 이는 클로저를 활용했기 때문에 가능하다.
    setState((prev) => prev + 1);
  }

  // ...
}
```

함수가 선언된 환경(state가 저장되어 있는 어딘가)를 기억하기 때문에 계속해서 state 값을 사용할 수 있다.

### 1.4.4 주의할 점

클로저는 개념을 정확히 이해해야 잘 활용할 수 있다.

```jsx
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
}
```
위 코드를 실행하면 0, 1, 2, 3, 4초 뒤에 5만 출력된다. i가 전역 변수로 작동하기 때문에 태스크 큐에 있는 setTimeout을 실행하는 시점에는 순회를 끝난 i는 5가 되므로 5만 출력이 된다.

이를 올바르게 수정하는 방법은 블록 레벨 스코프를 갖는 let으로 수정하거나 클로저를 제대로 활용하는 것이다.

```jsx
// 블록 레벨 스코프로 수정
for (let i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
}

// 클로저 활용
for (var i = 0; i < 5; i++) {
  setTimeout(
    (function (sec) {
      // 함수는 고유한 스코프인 sec을 갖게 되므로 올바르게 동작한다.
      return function () {
        console.log(sec);
      };
    })(i),
    i * 1000,
  );
}
```



클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 메모리 공간이 필요하다. 

```jsx
// 일반적인 함수
const aButton = document.getElementById('a');

function heavyJob() {
  const longArr = Array.from({ length: 10000000 }, (_, i) => i + 1);
  console.log(longArr.length);
}
aButton.addEventListener('click', heavyJob);
```
- 크롬 개발자 도구에서 확인해 보면 메모리의 전체 크기도 작고, 실행 전후로도 큰 차이가 없다.
- 실행 전(13.MB) -> 실행 후(13.MB)

```jsx
// 클로저라면?
function heavyJobWithClosure() {
  const longArr = Array.from({ length: 10000000 }, (_, i) => i + 1);
  return function () {
    console.log(longArr.length);
  };
}

const innerFunc = heavyJobWithClosure();
bButton.addEventListener('click', function () {
  innerFunc;
});
```
- 크롬 개발자 도구에서 확인해 보면 스크립트 실행 시점부터 메모리 크기가 크다.
- 실행 전(41.1MB) -> 실행 후(41.1MB)

그러므로 클로저에 꼭 필요한 작업만 남겨두지 않는다면 메모리를 불필요하게 잡아먹는 결과를 야기해 성능에 악영향을 미친다.

```jsx
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
}

```

### 1.4.5 정리

- 클로저는 함수형 프로그래밍의 중요한 개념, 부수 효과가 없고 순수해야 한다는 목적을 달성하기 위해 적극적으로 사용된다.
- 클로저는 공짜가 아니므로 주의해서 사용해야 한다.
