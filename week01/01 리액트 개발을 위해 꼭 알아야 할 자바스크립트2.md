# 01 리액트 개발을 위해 꼭 알아야 할 자바스크립트2

## 1.4 클로저
클로저를 통해 함수 컴포넌트를 이해할 수 있다. 함수 컴포넌트의 구조와 작동 방식, 훅의 원리, 의존성 배열 등 함수 컴포넌트의 대부분의 기술이 모두 클로저에 의존하고 있어 클로저에 대한 이해는 필수이다.

### 1.4.1 클로저의 정의

클로저는 함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합이다.

**어휘적 환경이란?**

```jsx
function add() {
  const a = 10;
  function innerAdd() {
    const b = 20;
    console.log(a + b);
  }
}
```

변수의 유효 범위는 코드가 작성된 순간에 정적으로 결정되므로 innerAdd는 add 내부에서 선언돼 있어 a를 사용할 수 있다. 여기서 "선언된 어휘적 환경"은 변수가 코드 내부에서 어디서 선언됐는지를 말하는 것이다. 클로저는 이러한 어휘적 환경을 조합해 코딩하는 기법이다.

### 1.4.2 변수의 유효 범위, 스코프 
변수의 유효 범위를 스코프라고 한다.

**전역 스코프**

브라우저 환경에서 window, Node.js 환경에서 global이 있다. 전역 레벨에 선언하면 이 객체에 스코프가 바인딩 된다.

**함수 스코프**

자바스크립트는 기본적으로 함수 레벨 스코프를 따른다. 즉 {} 블록이 스코프 범위를 정하지 않는다.

### 1.4.3 클로저의 활용

**클로저의 활용**

```jsx
function Counter() {
  var counter = 0;
  return {
    increase: function () {
      return ++counter;
    },
    decrease: function () {
      return --counter;
    },
    counter: function () {
      console.log(' counter에 접근!');
      return counter;
    },
  };
}
var c = Counter();

console.log(c.increase()); // 1
console.log(c.increase()); // 2
console.log(c.increase()); // 3
console.log(c.decrease()); // 2
console.log(c.counter()); // 2
```
클로저를 이용했을 때의 장점:
- counter 변수를 직접적으로 노출하지 않음으로써 사용자가 직접 수정하는 것을 막는다.
- 변수의 업데이트를 increase와 decrease로 제한해 무분별하게 변경되는 것을 막는다.

클로저를 활용하면 전역 스코프의 사용을 막고, 개발자가 원하는 정보만 개발자가 원하는 방향으로 노출시킬 수 있다.

**리액트에서의 클로저**

클로저의 원리를 사용하고 있는 대표적인 것 중 하나가 useState이다. 클로저를 이용해 리액트가 관리하는 내부 상태 값은 리액트가 별도로 관리하는 클로저 내부에서만 접근할 수 있다.

```jsx
function Component() {
  const [state, setState] = useState();

  function handleClick() {
    // usestate 호출은 위에서 끝났지만,
    // setstate는 계속 내부의 최신값(prev)을 알고 있다.
    // 이는 클로저를 활용했기 때문에 가능하다.
    setState((prev) => prev + 1);
  }

  // ...
}
```

함수가 선언된 환경(state가 저장되어 있는 어딘가)를 기억하기 때문에 계속해서 state 값을 사용할 수 있다.

### 1.4.4 주의할 점

클로저는 개념을 정확히 이해해야 잘 활용할 수 있다.

```jsx
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
}
```
위 코드를 실행하면 0, 1, 2, 3, 4초 뒤에 5만 출력된다. i가 전역 변수로 작동하기 때문에 태스크 큐에 있는 setTimeout을 실행하는 시점에는 순회를 끝난 i는 5가 되므로 5만 출력이 된다.

이를 올바르게 수정하는 방법은 블록 레벨 스코프를 갖는 let으로 수정하거나 클로저를 제대로 활용하는 것이다.

```jsx
// 블록 레벨 스코프로 수정
for (let i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
}

// 클로저 활용
for (var i = 0; i < 5; i++) {
  setTimeout(
    (function (sec) {
      // 함수는 고유한 스코프인 sec을 갖게 되므로 올바르게 동작한다.
      return function () {
        console.log(sec);
      };
    })(i),
    i * 1000,
  );
}
```



클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 메모리 공간이 필요하다. 

```jsx
// 일반적인 함수
const aButton = document.getElementById('a');

function heavyJob() {
  const longArr = Array.from({ length: 10000000 }, (_, i) => i + 1);
  console.log(longArr.length);
}
aButton.addEventListener('click', heavyJob);
```
- 크롬 개발자 도구에서 확인해 보면 메모리의 전체 크기도 작고, 실행 전후로도 큰 차이가 없다.
- 실행 전(13.MB) -> 실행 후(13.MB)

```jsx
// 클로저라면?
function heavyJobWithClosure() {
  const longArr = Array.from({ length: 10000000 }, (_, i) => i + 1);
  return function () {
    console.log(longArr.length);
  };
}

const innerFunc = heavyJobWithClosure();
bButton.addEventListener('click', function () {
  innerFunc;
});
```
- 크롬 개발자 도구에서 확인해 보면 스크립트 실행 시점부터 메모리 크기가 크다.
- 실행 전(41.1MB) -> 실행 후(41.1MB)

그러므로 클로저에 꼭 필요한 작업만 남겨두지 않는다면 메모리를 불필요하게 잡아먹는 결과를 야기해 성능에 악영향을 미친다.

```jsx
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
}

```

### 1.4.5 정리

- 클로저는 함수형 프로그래밍의 중요한 개념, 부수 효과가 없고 순수해야 한다는 목적을 달성하기 위해 적극적으로 사용된다.
- 클로저는 공짜가 아니므로 주의해서 사용해야 한다.

## 1.5 이벤트 루프와 비동기 통신의 이해 

비동기란 직렬 방식이 아닌 병령 방식으로 작업을 처리하는 것을 의미한다. 요청에 대한 응답이 오건 말건 상관없이 다음 작업이 이루어 지며, 따라서 한 번에 여러 작업이 실행될 수 있다.

웹에서 비동기 작업을 수행해 사용자에게 여러 작업을 제공할 수 있다. 예를 들어 사용자가 검색어를 입력해 검색을 위한 네트워크 요청이 발생하는 순간에도 사용자의 다른 작업을 처리할 수 있다.

비동기 작업이 어떻게 처리되는지 이해하면 어떻게 여러 가지 요청을 동시에 처리하고 있는지, 이러한 요청받은 태스크에 대한 우선순위는 무엇인지, 주의할 점은 무엇인지 파악해 사용자에게 더욱 매끄러운 웹 어플리케이션 서비스를 제공할 수 수 있다.

### 1.5.1 싱글 스레드 자바스크립트

<details>
    <summary>자바스크립트는 왜 싱글 스레드로 설계됐을까?</summary>
    1995년 당시  멀티 스레드에 대한 개념이 대중화되지 않았다. 그리고 LiveScript(자바스크립트의 전신)은 브라우저에 아주 간단한 스크립트를 지원할 목적으로 시작됐다. 폼을 처리하거는 등 아주 제한적으로 사용하기 위해 싱글 스레드로 설계되었다.
</details>


자바스크립트에서 싱글 스레드라는 것은 코드의 실행이 하나의 스레드에서 순차적으로 이뤄지는 것을 의미한다. 그러므로 하나의 코드가 실행하는 데 오래 걸리면 뒤이은 코드가 실행되지 않는다.(Run-to-completion.) 결론적으로 자바스크립트의 모든 코드는 **동기식**으로 한 번에 하나씩 순차적으로 처리된다.

비동기는 동기식과 다르게 요청에 대한 응답이 언제 올지 알 수 없다. 비동기를 이용하면 여러 작업을 동시에 수행할 수 있다. 

자바스크립트 세상에서 비동기 코드를 처리할 수 있는 방법을 알아보자.

### 1.5.2 이벤트 루프란?

지금부터 설명하는 내용은 자바스크립트 런타임 중 가장 유명한 V8기준으로 작성됐다. 

이벤트 루프는 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치이다. V8, Spider Monkey 같은 현대 자바스크립트 런타임 엔진에는 자바스크립트 코드를 효과적으로 실행하기 위한 여러가지 장치들이 마련되어 있다.

**호출 스택과 이벤트 루프**

호출 스택은 자바스크립트에서 수행해야 할 코드나 함수를 순착적으로 담아두는 스택이다.

이벤트 루프는 호출 스택이 비어 있는지 여부를 확인하는 것이다. 이벤트 루프는 단순히 이벤트 루프만의 단일 스레드 내부에서 이 호출 스택 내부에 수행해야 할 작업이 있는지 확인하고, 수행해야 할 코드가 있다면 자바스크립트 엔진을 이용해 실행한다. 주의할 점은 '코드를 실행하는 것'과 '호출 스택이 비어 있는지 확인하는 것' 모두 단일 스레드에서 일어난다.


비동기 작업은 어떻게 실행될까?
```jsx
function bar() {
  console.log('bar');
}

function baz() {
  console.log('baz');
}

function foo() {
  console.log('foo');
  setTimeout(bar(), 0); // setTimeout만 추가했다.
  baz();
}

foo();
```

1. foo()가 호출 스택에 먼저 들어간다.
2. foo() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
3. 2의 실행이 완료된 이후에 다음 코드로 넘어간다. (아직 foo()는 존재)
4. setTimeout(bar(), 0)이 호출 스택에 들어간다.
5. 4번에 대해 타이머 이벤트가 실행되며 태스크 큐로 들어가고, 그 대신 바로 스택에서 제거된다.
6. baz()가 호출 스택에 들어간다.
7. baz() 내부에 console. Log가 존재하므로 호출 스택에 들어간다.
8. 7의 실행이 완료된 이후에 다음 코드로 넘어간다. (아직 foo(), ba2()는 존재)
9.  더 이상 baz()에 남은 것이 없으므로 호출 스택에서 제거된다. (아직 foo()는 존재)
10. 더 이상 foo()에 남은 것이 없으므로 호출 스택에서 제거된다.
11. **이제 호출 스택이 완전히 비워졌다.**
12. 이벤트 루프가 호출 스택이 비워져 있다는 것을 확인했다. 그리고 태스크 큐를 확인하니 4번에 들어갔던 내용이 있어 bar()를 호출 스택에 들여보낸다.
13. bar() 내부에 console. Log가 존재하므로 호출 스택에 들어간다.
14. 13의 실행이 끝나고, 다음 코드로 넘어간다. (아직 bar () 존재)
15. 더 이상 bar()에 남은 것이 없으므로 호출 스택에서 제거된다.


여기서 태스크 큐라는 새로운 개념이 등장한다. 태스크큐란 실행해야 할 태스크의 집합을 의미한다. 이벤트 루프는 이러한 태스크 큐를 한 개 이상 가지고 있다. 태스크 큐는 실행 가능한 가장 오래된 태스크를 처리하기 위해 큐가 아닌 set형태이다. 

이벤트 루프의 역할:

- 호출 스택에 실행 중인 코드가 있는지, 태스크 큐에 대기 중인 함수가 있는지  반복해서 확인하는 역할 
- 호출 스택이 비어있다면 태스크 큐에 대기 중인 작업이 있는지 확인하고 작업을 순차적으로 꺼내와 실행 
- 이 작업은 태스크 큐가 빌 때까지 이루어짐

비동기 함수(n초 뒤에 setTimeout 요청하는 작업)은 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드에서 수행된다. 이는 브라우저나 Node.js의 역할이다. 즉, 자바스크립트의 코드 실행은 싱글 스레드에서 이루어지지만 이러한 외부 WEB API 등은 모두 자바스크립트 코드 외부에서 실행되고 콜백이 태스크 큐로 들어간다. 

### 1.5.3 태스크 큐와 마이크로 태스크 큐

이벤트 루프는 하나의 마이크로 태스크 큐를 갖고 있다. 마이크로 태스크 큐는 태스크 큐와는 다른 작업을 처리하고 우선권을 가지므로 setTimeout과 setInterval은 Promise보다 늦게 실행된다. 명세에 따르면 마이크로 태스크 큐가 빌 떄까지 기존 태스크 큐의 실행은 뒤로 미루어진다.

각 태스크에 들어가는 대표적인 작업은 다음과 같다.
- 태스크 큐: setTimeout, setInterval, setImmediate
- 마이크로 태스크 큐: process.nextTick, Promises, queueMicroRask, MutationObserver

그렇다면 렌더링은 언제 실행될까? 렌더링은 각 마이크로 태스크 큐 작업이 끝날 때마다 한 번씩 렌더링할 기회를 얻게 된다. (마이크로 태스크 큐 -> 렌더링 -> 태스크 큐)

```jsx
const button = document.getElementById('run');
const sync = document.getElementById('sync');
const macrotask = document.getElementById('macrotask');
const microtask = document.getElementById('microtask');
const macro_micro = document.getElementById('macro_micro');

// 동기 코드로 버튼에 1부터 렌더링
sync.addEventListener('click', function () {
  for (let i = 0; i <= 100000; i++) {
    sync.innerHTML = i;
  }
});

// setTimeout으로 태스크 큐에 작업을 넣어서 1부터 렌더링
macrotask.addEventlistener('click', function () {
  for (let i = 0; i <= 100000; i++) {
    setTimeout(() => {
      macrotask.innerHTML = i;
    }, 0);
  }
});

// queuenicrotask로 마이크로 태스크 큐에 넣어서 1부터 렌더링
microtask.addEventListener('click', function () {
  for (let i = 0; i <= 100000; i++) {
    queueMicrotask(() => {
      microtask.innerHTML = i;
    });
  }
});

macro_micro.addEventListener('click', function () {
  for (let i = 0; i <= 100000; i++) {
    sync.innerHTML = i;
    setTimeout(() => {
      macrotask.innerHTML = i;
    }, 0);
    queueMicrotask(() => {
      microtask.innerHTML = i;
    });
  }
});
```
위 코드의 결과를 정리하면 다음과 같다.
- 동기 코드는 for 문이 끝나야 비로소 렌더링 기회를 얻어 100,000이라는 숫자가 한 번에 나타난다.
- 태스크 큐는 모든 setTimeout 콜백이 큐에 들어가기 전까지 대기 시간을 갖다가 1부터 100,000까지 순차적으로 렌더링 된다.
- 마이크로 태스크 큐는 동기 코드와 마찬가지로 for 문이 끝난 후 렌더링 기회를 얻어 100,000이라는 숫자가 한 번에 나타난다.
- 모든 것을 동시에 실행했으 ㄹ경우, 태스크 큐만 앞선 예제처럼 순차적으로 렌더링 된다.

이러한 작업 순서는 브라우저에 다음 리페인트 전에 콜백 함수 호출을 가능하게 하는 requestAnimationFrame으로도 확인할 수 있다. 

```jsx
console.log('a');

setTimeout(() => {
  console.log('b');
}, 0);

Promise.resolve().then(() => {
  console.log('c');
});

window.requestAnimationFrame(() => {
  console.log('d');
});
```

출력 결과는 a, c, d, b이다. 이를 통해 브라우저에 렌더링하는 작업은 마이크로 태스크 큐와 태스크 큐 사이에 일어나는 것을 알 수 있다.

동기 코드는 물론이고 마이크로 태스크 또한 마찬가지로 렌더링에 영향을 미칠 수 있으므로 무거운 작업이 렌더링과 관련있다면 어떤 식으로 분리하면 좋을지 고민해 보아야 한다.

## 1.5.4 정리
- 태스크 큐, 이벤트 루프, 마이크로 태스크 큐, 브라우저/Node.js API 등이 적절한 생태계를 이뤄 자바스크립트에서 비동기 이벤트 처리가 가능해졌다.
