# 03장: 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표

## 12.1 웹사이트와 성능

2019년, 미국 디지털 마케팅 회사 `Protent`의 조사 결과는 다음과 같다.

1. 1초 내로 로딩되는 사이트는 5초 내로 로딩되는 사이트보다 구매로 이어지는 고객 비율이 2.5배 더 높다.
2. 0 ~ 5초 범위에서, 1초 로딩이 늦어질수록 전환율은 4.42%씩 떨어진다. (5초 = 약 20%)
3. 소비자의 70%는 페이지 속도가 온라인 커머스에서 중요하다고 밝혔으며, 빠르다면 애니메이션이나 동영상은 필요 없다고 밝혔다.

구글에서도 비슷한 웹사이트 성능에 관한 통계를 내놓았다.

1. 전체 웹페이지를 표시하는 데 필요한 최적 리소스 요청 수는 약 50회 미만
2. 평균적으로 웹페이지 전체를 요청하는 데 15.3초 소요
3. 페이지 로드 시간이 1초에서 10초로 늘어날수록 사이트 이탈율이 123% 증가

이러한 점에서 보통 개발자는 성능 문제에 관심을 갖지 않는다.  
왜 그러냐면..

1. 개발자의 기기는 보통 일반 사용자보다 성능이 뛰어나서 문제를 겪지 못한다.
2. 성능 개선 작업은 쉽지도 재밌지도 않으며, 서비스 개발보다 눈에 띄는 성능 향상을 기대하기도 어렵다.

## 12.2 핵심 웹 지표란?

`Core Web Vital`로 알려져 있는 이 지표는, 구글에서 만든 웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표다.

### 핵심 웹 지표

- 최대 콘텐츠풀 페인트 (`LCP` : Largest Contentful Paint)
- 최초 입력 지연 (`FID` : First Input Delay)
- 누적 레이아웃 이동 (`CLS` : Cumulative Layout Shift)

### 그 외 지표

- 최초 바이트까지의 시간 (`TTFB` : Time To First Byte)
- 최초 콘텐츠풀 시간 (`FCP` : First Contentful Paint)

<!-- TODO: https://nextjs.org/docs/pages/building-your-application/configuring/eslint -->

`Next.js`의 `EsLint`에서도 기본적으로 이와 같은 지표를 제공한다.

## 12.3 최대 콘텐츠풀 페인트 (LCP)

### 정의

> 페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간

뷰포트 내부에서 가장 큰 이미지 또는 텍스트란?

- `<img>`
- `<svg>` 내부의 `<image>`
- `poster` 속성을 사용하는 `<video>`
- `url()`을 통해 불러온 배경 이미지가 있는 요소
- 텍스트와 같이 인라인 텍스트 요소를 포함하는 블록 레벨 요소 (`<p>`, `<div>` 등)

이러한 엘리먼트가 언제 노출되는지 확인하는 정확한 시점 = **각 엘리먼트가 등장한 시점부터 텍스트 또는 이미지가 완전히 로딩되는 시점**

→ **뷰포트 내부에서 가장 큰 영역을 차지하는 요소가 렌더링되는 데 어마나 걸리는지를 측정한 지표**

만약 뷰포트 영역 밖이라면, 해당 크기는 고려하지 않는다.

### 의미

> 웹페이지가 로딩이 완료되어 사용자에게 노출되기까지 걸리는 시간이란?

`DOMContentLoaded` 이벤트

- HTML 문서를 완전히 불러오고 파싱했을 때 발생하는 이벤트
- 스타일시트, 이미지, 하위 프레임의 로딩은 기다리지 않기 때문에, "페이지가 로딩되었다"라고 볼 수는 없다.

#### 사용자가 페이지 로딩을 체감하기 위해 꼭 페이지가 완전히 로딩될 필요는 없다.

- 코드 수가 1만 줄이어도 `IntersectionObserver`로 구현되었다면, 사용자에게 노출되는 부분만 로딩된다면 로딩이 완료되었다고 느낄 것이다.
- 즉, 사용자에게 `로딩`이란, 뷰포트에 보이는 영역을 기준으로 하기 때문에, **뷰포트에 메인 컨텐츠가 전달되는 속도**를 기준으로 측정할 수 있다.

→ "사용자에게 페이지의 정보를 화면에 전달하는 속도" 를 판단하기 위해 만들어진 지표 = `LCP`

### 기준 점수

- 2.5초 내로 응답이 오면 `Good`
- 4초 내로 응답이 오면 `Fair`
- 그 이상 `Bad`

### 개선 방안

1. 텍스트는 언제나 옳다.

- 가능한 한 `LCP` 예상 영역에는 이미지가 아닌 문자열을 넣을 것

2. 이미지는 어떻게 불러올 것인가?

→ `img`, `video` 가 이미지 노출 속도가 빠르다.

- `img`

  - 이미지는 브라우저의 `preload scanner`에 의해 빠르게 요청이 일어난다.
  - HTML 파싱이 완료되지 않더라도, 병렬적으로 리소스를 다운로드하므로 `LCP` 요소를 불러오기 적합하다.

- `svg` 내부의 `img`

  - `preload scanner`에 발견되지 않아 병렬적 다운로드가 일어나지 않는다.

- `video`의 `poster`

  - `poster` : 사용자가 `video` 요소를 재생하거나 탐색하기 전까지 노출되는 요소
  - `preload scanner`에 의해 먼저 발견되어, `img`와 같은 성능을 보인다.
  - `poster`가 없는 `video`는 실제로 비디오를 로딩해, 첫 프레임을 사용한다.
    - 즉 성능이 하락하므로 `LCP`에 영향을 받을 것 같다면 `poster`를 사용할 것

- `background-image`
  - `url(): background-image`를 비롯해, **css 리소스는 항상 느리다.**

### 그 밖에 주의 사항

- 이미지 무손실 압축
  - 웹서비스 이미지는 가능한 한 무손실 형식으로 압축하여, 최소한의 용량으로 서비스할 것
- `loading=lazy` 주의
  - 리소스를 중요하지 않다고 표시하고, 필요할 때만 로드하는 전략
  - `LCP`의 이미지를 중요하지 않다고 분류하면..?
- `fadein` 같은 각종 애니메이션
  - `fadeIn ease 10s` 등의 애니메이션 처리를 한다면, `LCP`도 그 시간만큼 느려진다.
- 클라이언트에서 빌드하지 말 것
  - 서버에서 빌드한 HTML을 `preload scanner`가 읽어 `LCP`로 빠르게 가져가는 것이 좋다.
- `LCP`는 직접 호스팅
  - 다른 origin에서 이미지를 가져오는 것은 최적화에 좋은 영향이 아님
  - 중요한 리소스는 직접 다루고, 덜 중요한 리소스만 이미지 최적화 서비스를 사용할 것

## 12.4 최초 입력 지연 (FID)

### 정의

> 사용자가 페이지와 처음 상호 작용할 때부터 해당 상호 작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간

### 의미
