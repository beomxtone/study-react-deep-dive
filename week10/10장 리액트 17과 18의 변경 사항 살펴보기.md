# 10장 리액트 17과 18의 변경 사항 살펴보기

![image](https://github.com/user-attachments/assets/f6b8bcdb-eb22-4334-9fcb-6c70fa433342)

리액트는 npm-stats를 기준, 현재 10억 다운로드를 달성했다.

![image](https://github.com/user-attachments/assets/c4c2bc9d-c9ea-4b91-8865-4b60240d1ac0)

2024년 8월을 기준으로 메타 팀은 리액트를 18.3.1 버전까지 릴리스했는데, W3Techs에서 분석한 결과, 16버전이 가장 많이 사용되고 있다.

<img width="1528" alt="제목 없음" src="https://github.com/user-attachments/assets/98980ec5-f6c5-48b2-a8aa-c276fa3cd9bb">

그러나 2022년 8월 기준 리액트 16 버전을 사용하던 에어비앤비와 넷플릭스 모두 현재는 리액트 18 버전으로 업데이트되었다.

17버전과 18버전에서 어떤 변화가 있었는지 살펴보자.

## 10.1 리액트 17 버전 살펴보기

### 10.1.1 리액트의 점진적인 업그레이드

새로운 버전이 릴리스되면 전체 웹 서비스가 새로운 버전으로 완전히 넘어가버리거나, 계속 과거 버전에 머물러 있어야 한다.

그러나 리액트 17 버전부터는 **점진적인 업그레이드**가 가능해진다.

점진적인 업그레이드를 지원하기 위한 **리액트의 일부 컴포넌트 변경**이 리액트 17 업데이트의 주요 변경 사항 중 하나이다.

> '한 애플리케이션 내에 여러 버전의 리액트가 존재하는 시나리오'를 살펴보자.

legacy: react@16을 기반으로 작성된 컴포넌트<br/>
legacy/package.json
```json
{
  "private": true,
  "name": "react@16 application",
  "dependencies": {
    "react": "16.8",
    "react-dom": "16.8"
  }
}
```

legacy/createLegacyRoot.js
```js
// 📌 구 리액트 애플리케이션 루트를 만든다.
export default function createLegacyRoot(container) {
  return {
    // 렌더링
    render(Component, props, context) {
      ReactDOM.render(
        <ThemeContext.Provider value={context.theme}>
          <Component {...props} />
        </ThemeContext.Provider>,
        container
      );
    },
    // 이 컴포넌트의 부모 컴포넌트가 제거될 때 호출될 unmount
    unmount() {
      ReactDOM.unmountComponentAtNode(container);
    },
  };
}
```

modern: react@17을 기반으로 작성된 컴포넌트가 모여있으며, 애플리케이션의 시작점이다.<br/>
modern/package.json
```json
{
  "private": true,
  "name": "react@17 application",
  "dependencies": {
    "react": "17.0.0",
    "react-dom": "17.0.0"
  }
}
```

modern/lazyLegacyRoot.js
```js
const rendererModule = {
  status: 'pending',
  promise: null,
  result: null,
};

export default function lazyLegacyRoot(getLegacyComponent) {
  const componentModule = {
    status: 'pending',
    promise: null,
    result: null,
  };

  return function Wrapper(props) {
    // 📌 legacy/createLegacyRoot 를 promise 로 lazy 하게 불러온다.
    const createLegacyRoot = readModule(rendererModule, () =>
      import('../legacy/createLegacyRoot')
    ).default;

    const Component = readModule(componentModule, getLegacyComponent).default;
    // 구 리액트를 렌더링할 위치
    const containerRef = useRef(null);
    // 구 리액트의 루트 컴포넌트
    const rootRef = useRef(null);

    const theme = useContext(ThemeContext);
    const context = useMemo(
      () => ({
        theme,
      }),
      [theme]
    );
    useLayoutEffect(() => {
      // 루트 컴포넌트가 없다면
      if (!rootRef.current) {
        // 루트 컴포넌트를 만든다.
        rootRef.current = createLegacyRoot(containerRef.current);
      }
      const root = rootRef.current;

      // cleanUp 시에 unmount
      return () => {
        root.unmount();
      };
    }, [createLegacyRoot]);

    useLayoutEffect(() => {
      if (rootRef.current) {
        // 루트 컴포넌트가 존재하면 적절한 props와 context로 렌더링한다.
        rootRef.current.render(Component, props, context);
      }
    }, [Component, props, context]);

    // 📌 여기에 구 리액트 애플리케이션 코드가 들어간다.
    return <div style={{display: 'contents'}} ref={containerRef} />;
  };
}
```

modern/AboutPage.js
```js
// 리액트 16 버전의 Greeting Component를 불러온다.
const Greeting = lazyLegacyRoot(() => import('../legacy/Greeting'));

export default function AboutPage() {
  const theme = useContext(ThemeContext);
  return (
    // 📌 전체 코드는 리액트 17로 작성되지만
    <>
      <h2>src/modern/AboutPage.js</h2>
      <h3 style={{color: theme}}>
        This component is rendered by the outer React ({React.version}).
      </h3>
        <Clock />
        { /* 📌 여기는 리액트 16 코드가 존재한다. */}
        <Greeting />
      <br />
    </>
  );
}
```

리액트 17 애플리케이션은 내부에서 리액트 16을 게으르게(lazy) 불러온다. 불러오는 과정에서 리액트 16을 위한 별도의 루트 요소를 만들고, 여기에 불러온 리액트 16 모듈을 렌더링하는 구조로 구성돼 있다.

이 두 개의 리액트 루트는 단 하나만 존재하는 컴포넌트와 훅을 서로 불러와서 사용할 수 있다.

리액트 팀에서는 이를 어디까지나 **한꺼번에 업그레이드가 불가능한 상태에서만 차선책**으로 사용하기를 권고했다.

### 10.1.2 이벤트 위임 방식의 변경

![image](https://github.com/user-attachments/assets/25aed494-7629-4081-8dc8-df048cc9c364)

1. 캡처(capture): 이벤트 핸들러가 트리 최상단 요소부터 타깃 요소까지 내려가는 것
2. 타깃(target): 이벤트 핸들러가 타깃 노드에 도달하는 단계. 이 단계에서 이벤트가 호출됨
3. 버블링(bubling): 이벤트가 발생한 요소부터 최상위 요소까지 다시 올라가는 것

이벤트는 이러한 단계로 구성돼 있다.

리액트는 이벤트 핸들러를 해당 이벤트 핸들러를 추가한 각각의 DOM 요소에 부탁하는 것이 아니라, **이벤트 위임**을 통해 관리한다.

이벤트 위임이란 이벤트 단계의 원리를 활용해 **이벤트를 상위 컴포넌트에만 붙이는 것**을 의미한다.

자식 노드가 변경되더라도 이벤트 핸들러를 수정할 필요가 없고, 이벤트 추가를 한 번만 하면 되므로 좀 더 효율적으로 관리할 수 있다.

이러한 이벤트 위임이 리액트 16 버전까지는 모두 document에서 수행되고 있었다.

![image](https://github.com/user-attachments/assets/0a82a00d-a093-4126-b4a9-580e28efe5aa)

그러나 리액트 17부터는 이러한 이벤트 위임이 모두 document가 아닌 리액트 컴포넌트 최상단 트리, 즉 루트 요소로 바뀌었다.

![image](https://github.com/user-attachments/assets/c0843fba-10a0-4998-bd71-f48d0fe9a624)

그 이유는 앞서 이야기한 **점진적인 업그레이드 지원**, 그리고 **다른 바닐라 자바스크립트 코드 또는 jQuery 등이 혼재돼 있는 경우 혼란을 방지하기 위해서**다.

![image](https://github.com/user-attachments/assets/5d6431a4-8eaa-4a8f-9880-19558ba9eec2)

리액트 16 버전에서 document와 리액트가 렌더링되는 루트 컴포넌트 사이에서 이벤트를 막는 코드를 추가하면 리액트의 모든 핸들러가 작동하지 않도록 막을 수 있었다. 이제 이러한 작동 방식 또한 이벤트 위임 방식이 변경되면서 사라졌다.

### 10.1.3 import React from 'react'가 더 이상 필요없다: 새로운 JSX transform

JSX는 브라우저가 이해할 수 있는 코드가 아니므로 바벨이나 타입스크립트를 활용해 JSX를 실행하기 위해 일반적인 자바스크립로 변환하는 과정이 꼭 필요하다.

이러한 JSX 변환을 사용하기 위해 코드 내에서 React를 사용하는 구문이 없더라도 import React from 'react'가 필요했지만, **리액트 17부터 바벨과 협력해 이러한 import 구문 없이도 JSX를 변환할 수 있게 됐다.**

```jsx
const Component = (
  <div>
    <span>hello world</span>
  </div>
)
```
이러한 코드를 작성하면, 구 버전에서는 이렇게 변환된다.
```jsx
var Component = React.createElement(
    'div',
    null,
    React.createElement("span", null, "hello world")
)
```
JSX 코드를 변경은 해주지만, React.createElement를 수행할 때 필요한 import React from 'react'는 추가해주지 않는다.

그러나 17 버전에서는 앞의 코드가 다음과 같이 변환된다.
```jsx
'use strict'

var _jsxRuntime = require('react/jsx-runtime')

var Component = (0, _jsxRuntime.jsx)('div', {
  children: (0, _jsxRuntime.jsx)('span', {
    children: 'hello world',
  }),
})
```
createElement가 사라졌고, require() 구문이 추가됐다.

require 구문으로 JSX를 변환할 때 필요한 모듈인 react/jsx-runtime을 불러오기 때문에 import React from 'react'를 작성하지 않아도 된다.

### 10.1.4 그 밖의 주요 변경 사항

> 이벤트 풀링 제거

<details>
  <summary>이벤트 풀링</summary>
이벤트 풀링이란 합성 이벤트(SyntheticEvent) 풀을 만들어서 이벤트가 발생할 때마다 가져오는 것을 의미한다.

SyntheticEvent 객체는 모든 브라우저에서 이벤트를 동일하게 처리하기 위한 래퍼 객체이다.

SyntheticEvent 객체는 재사용되고 모든 속성은 이벤트 핸들러가 호출된 다음 초기화된다. 따라서 비동기적으로 이벤트 객체에 접근할 수 없다.

```js
function handleChange(e) {
  // Cannot read properties of null (reading 'value') 에러 발생
  setTimeout(() => {
    console.log(e.target.value); // Too late!
  }, 100);
}
```

비동기 코드 내부에서 SyntheticEvent인 e에 접근하면 이미 사용되고 초기화된 이후이기 때문에 null만 얻게 된다. e에 접근하기 위해서는 추가적인 작업인 e.persist()같은 처리가 필요하다.

```js
function handleChange(e) {
  // Prevents React from resetting its properties:
  e.persist();

  setTimeout(() => {
    console.log(e.target.value); // Works
  }, 100);
}
```

</details>

리액트 17에서는 리액트 16의 이벤트 풀링 개념이 삭제됐다. 따라서 이벤트 핸들러 내부에서 이벤트 객체에 접근할 때 비동기든 동기든 상관없이 일관적으로 코딩할 수 있게 됐다.

> useEffect 클린업 함수의 비동기 실행

클린업 함수는 리액트 16 버전까지는 동기적으로 처리됐다. 이는 클린업 함수가 완료되기 전까지 다른 작업을 방해하기 때문에 불필요한 성능 저하로 이어지는 문제가 존재했다.

그러나 리액트 17 버전부터는 컴포넌트의 커밋 단계가 완료된 이후에 비동기적으로 실행된다.

> 컴포넌트의 undefined 반환에 대한 일관적인 처리

리액트 16과 17 버전은 내부에서 undefined를 반환하면 오류가 발생한다.

그러나 리액트 16에서는 forwardRef나 memo에서 undefined를 반환하는 경우 에러가 발생하지 않는 문제가 있었다.

리액트 17부터는 에러가 정상적으로 발생한다. 참고로 리액트 18부터는 undefined를 반환해도 에러가 발생하지 않는다.

### 10.1.5 정리

리액트 17의 모든 변경 사항은 공식 문서와 깃허브 릴리스 태그에 있는 변경 사항을 확인해 보면 알 수 있다.

- https://ko.legacy.reactjs.org/blog/2020/10/20/react-v17.html
- https://ko.legacy.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html
- https://ko.legacy.reactjs.org/blog/2020/08/10/react-v17-rc.html
- https://github.com/facebook/react/releases/tag/v17.0.0
