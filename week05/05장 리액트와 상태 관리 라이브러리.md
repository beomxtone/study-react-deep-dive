# 05장 리액트와 상태 관리 라이브러리

이번 장에서는 **상태 관리 라이브러리의 필요성**과 상태 관리 라이브러리가 **어떻게 리액트와 함께 작동하는지** 살펴본다.

## 5.1 상태 관리는 왜 필요한가?

**'상태'란?**

- UI: 기본적으로 웹 애플리케이션에서 상태란, 상호 작용이 가능한 모든 요소의 현재 값을 의미한다.<br/>
  ex) 다크/라이트 모드, 라디오를 비롯한 각종 input, 알림찬의 노출 여부 등
- URL: 브라우저에서 관리되고 있는 상태값이다.<br/>
  ex) `https://www.airbnb.co.kr/rooms/34113796?adults=2`와 같은 주소에는 `roomId=34113796`과 `adults=2`라고 하는 상태가 존재한다.
- 폼(form): 로딩 중인지(loading), 현재 제출됐는지(submit), 접근이 불가능한지(disables), 값이 유요한지(validation) 등의 상태가 있다.
- 서버에서 가져온 값: 대표적으로 API 요청이 있다.

애플리케이션 전체적으로 관리해야할 상태가 있다고 가정하면 상태의 위치와 범위 관리, 상태 변화 감지, tearing 방지 등 상태 관리가 어려워진다.

<details>
<summary>tearing이란?</summary>

React 18의 Concurrent Rendering(동시성 렌더링)으로 인해 발생하는 UI의 불일치 현상이다.<br/>
React 18의 렌더링 과정에서 Suspend(일시 중지)가 발생했을 때, <br/>
렌더링 도중 React가 스토어를 업데이트해서 데이터가 변경되면, tearing(UI의 불일치)를 유발한다.

![image](https://github.com/parkyolo/study-react-deep-dive/assets/39394642/9b447c18-6189-4dcf-a345-5b7768d5f302)

</details>

### 5.1.1 리액트 상태 관리의 역사

리액트는 단순히 인터페이스를 만들기 위한 라이브러리이므로 상태를 관리하는 방법도 개발자에 따라, 시간에 따라 많은 차이가 있다. 그 역사를 살펴보자.

**Flux 패턴의 등장**

기존 MVC 패턴은 모델과 뷰가 많아질수록 복잡도가 증가한다.

![image](https://github.com/parkyolo/study-react-deep-dive/assets/39394642/f37d483b-0aca-4c2f-b8ec-161361d45279)

페이스북 팀은 이러한 문제의 원인을 양방향 데이터 바인딩 보고 양방향이 아닌 **단방향으로 데이터 흐름을 변경**하는 Flux 패턴을 제안한다.

![image](https://github.com/parkyolo/study-react-deep-dive/assets/39394642/7ef849d9-74ca-4722-b704-cdb6989c0f29)

- 액션(action): 어떠한 **작업을 처리할 액션**과 그 액션 발생 시 함께 포함시킬 **데이터**를 의미한다. 액션 타입과 데이터를 각각 정의해 이를 디스패처로 보낸다.
- 디스패처(dispatcher): 액션을 스토어에 보내는 역할을 한다. **콜백 함수 형태**로 앞서 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.
- 스토어(store): 여기에서 실제 상태에 따른 **값과 상태를 변경할 수 있는 메서드**를 가지고 있다.
- 뷰(view): **리액트의 컴포넌트**에 해당하는 부분으로, 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할을 한다. 뷰에서 **사용자의 입력이나 행위에 따라 상태를 업데이트**하고자 할 때 뷰에서 액션을 호출하는 구조로 구성된다.

```jsx
type StoreState = {
  count: number
}

// 액션 종류와 데이터 정의
type Action = { type: 'add'; payload: number }

function reducer(preState: StoreState, action: Action) {
  const { type: ActionType } = action
  if (ActionType === 'add') {
    return {
      count: prevState.count + action.payload,
    }
  }

  throw new Error(`Unexpected Action [${ActionType}]`)
}

export default App() {
  const [state, dispatcher] = useReducer(reducer, {count: 0})

  function handleClick() {
    // dispatcher로 action 실행
    dispatcher({ type: 'add', payload: 1})
  }

  return (
    // ...
  )
}
```


**시장 지배자 리덕스의 등장**

리덕스 또한 최초에는 Flux 구조를 표현하기 위해 만들어진 라이브러리 중 하나였다. 특별한 것은 여기에 Elm 아키텍처를 도입했다는 것이다.

Elm은 웹페이지를 선언적으로 작성하기 위한 언어다. Flux와 마찬가지로 데이터 흐름을 세 가지(model, update, view)로 분류하고, 이를 단방향으로 강제해 애플리케이션의 상태를 안정적으로 관리하고자 노력했다. 그리고 리덕스는 이 Elm 아키텍처의 영향을 받아 작성됐다.

리덕스는 **하나의 상태 객체를 스토어에 저장**해 두고, 이 객체를 **업데이트하는 작업을 디스패치**해 업데이트를 수행한다. 이러한 작업은 **reducer 함수**로 발생시킬 수 있는데, 이 함수의 실행은 애플리케이션 상태에 대한 **완전히 새로운 복사본**을 반환한 다음, 애플리케이션에 새롭게 만들어진 **상태를 전파**한다.

리덕스의 등장은 prop 내려주기 문제를 해결할 수 있었고, 스토어가 필요한 컴포넌트에서 connect만 쓰면 스토어에 바로 접근할 수 있게 되었다.

하지만 리덕스가 처음 등장했을 때 보일러플레이트가 너무 많다는 비판의 목소리가 있었다. 지금은 이러한 작업이 많이 간소화되었다.


**Context API와 useContext**

리액트 팀은 prop 내려주기 문제와 리덕스의 보일러플레이트의 부담을 해결하기 위해 리액트 16.3에서 전역 상태를 하위 컴포넌트에 주입할 수 있는 새로운 Context API를 출시했다.

Context API를 사용하면 원하는 곳에서 Context Provider가 주입하는 상태를 사용할 수 있게 된 것이다.

리액트 16.3 버전 이전에도 context가 존재했으며, 이를 다루기 위한 getChildContext() 예제를 보자.

```jsx
class MyComponent extends React.Component {
  // childContextTypes와 getChildContext()를 추가함으로써 React는 자동으로 정보를 하위에 전달한다.
  static childContextTypes = {
    name: PropTypes.string,
    age: PropTypes.number,
  };

  getChildContext() {
    return {
      name: 'foo',
      age: 30,
    }
  }

  render() {
    return <ChildComponent/>;
  }
}

function ChildComponent(props, context) {
  return (
    <div>
      <p>Name: {context.name}</p>
      <p>Age: {context.age}</p>
    </div>
  )
}

// contextTypes가 정의되지 않으면 context는 빈 객체가 된다.
ChildComponent.contextTypes = {
  name: PropTypes.string,
  age: PropTypes.number,
}
```

하지만 이 방식에는 문제점이 있다.

- 상위 컴포넌트가 렌더링되면 getChildContext도 호출됨과 동시에 shouldComponentUpdate가 항상 true를 반환해 **불필요하게 렌더링**이 일어난다는 점
- getChildContext를 사용하기 위해서는 context를 인수로 받아야 하므로 컴포넌트와 **결합도가 높아진다**는 점

이러한 단점을 해결하기 위해 16.3 버전에서 새로운 context가 출시됐다.

Context API를 사용해 하위 컴포넌트에 상태를 전달하는 예다.

```jsx
type Counter = {
  count: number
}

const CounterContext = createContext<Counter | undefined>(undefined)

class CounterComponent extends Component {
  render() {
    return (
      <CounterContext.Consumer>'
        {/* Provider로 주입된 상태를 자식 컴포넌트에서 사용 */}
        {(state) => <p>{state?.count}</p>}
      </CounterContext.Consumer>
    )
  }
}

class DummyParent extends Component {
  render() {
    return (
      <>
        <CounterComponent />
      </>
    )
  }
}

export default class MyApp extends Component<{}, Counter> {
  // 부모 컴포넌트인 MyApp에 상태 선언
  state = { count: 0 }

  componentDidMount() {
    this.setState({ count: 1 })
  }

  handleClick = () => {
    this.setState((state) => ({ count: state.count + 1 }))
  }

  render() {
    return (
      {/* Context로 상태 주입 */}
      <CounterContext.Provider value={this.state}>
        <button onClick={this.handleClick}>+</button>
        <DummyParent />
      </CounterContext.Provider>
    )
  }
}
```

그러나 Context API는 상태 관리가 아닌 주입을 도와주는 기능이며, 렌더링을 막아주는 기능 또한 존재하지 않으니 사용에 주의해야 한다.


**훅의 탄생, 그리고 React Query와 SWR**

Context API가 선보인 지 1년이 채 지나지 않아 리액트는 16.8 버전에서 함수 컴포넌트에 사용할 수 있는 다양한 훅 API를 추가했다.

훅과 state의 등장으로 이전에는 볼 수 없던 방식의 상태 관리인 React Query와 SWR이 등장한다.

두 라이브러리는 API 호출에 대한 상태를 관리하는 **HTTP 요청에 특화된 상태 관리 라이브러리**이다.

SWR을 사용한 코드를 살펴보자.

```jsx
import React from 'react'
import useSWR from 'swr'

const fetcher = (url) => fetch(url).then((res) => res.json())

export default function App() {
  const { data, error } = useSWR(
    'https://api.github.com/repos/vercel/swr',
    fetcher,
  )

  // ...
}
```

useSWR의 첫 번째 인수로 조회할 API 주소를, 두 번째 인수로 조회에 사용되는 fetch를 넘겨준다.

첫 번째 인수인 API 주소는 키로도 사용되며, 이후 다른 곳에서 동일한 키로 호출하면 useSWR이 관리하고 있는 캐시의 값을 활용한다.

제한적인 목적으로 사용되는 상태 관리 라이브러리이지만, 애플리케이션의 많은 부분에서 상태 관리 코드를 줄일 수 있다.


**Recoil, Zustand, Jotai, Valtio에 이르기까지**

```jsx
// Recoil
const counter = atom({ key: 'count', default: 0 })
const todoList = useRecoilValue(counter)

// Jotai
const countAtom = atom(0)
const [count, setCount] = useAtom(countAtom)

// Zustand
const useCounterStore = create((set) => ({
  count: 0,
  increase: () => set((state) => ({ count: state.count + 1})),
}))
const count = useCounterStore((state) => state.count)

// Valtio
const state = proxy({ count: 0 })
const snap = useSnapshot(state)
state.count++
```

새롭게 떠오르는 상태 관리 라이브러리와 기존의 리덕스 라이브러리의 차이점은, 훅을 활용해 작은 크기의 상태를 효율적으로 관리한다는 것이다.

Recoil, Zustand, Jotai, Valtio는 모두 아래와 같은 특징을 가진다.

- peerDependencies로 리액트 16.8 버전 이상을 요구함
- 별도로 다른 라이브러리를 설치하지 않아도 됨
- 지역적 상태 관리가 가능
- 훅을 지원함으로써 함수 컴포넌트에서 손쉽게 사용할 수 있음


## 5.2 리액트 훅으로 시작하는 상태 관리

리액트 16.8에서 등장한 훅과 함수 컴포넌트의 패러다임에서 애플리케이션 내부 상태 관리를 어떻게 할 수 있고, 어떠한 라이브러리가 있으며, 어떻게 작동하는지 알아보자.

### 5.2.1 가장 기본적인 방법: useState와 useReducer

useState와 useReducer로 만든 사용자 정의 훅은 함수 컴포넌트라면 어디서든 손쉽게 **재사용 가능**하다는 장점이 있다.

그러나 useState와 useReducer를 기반으로 하는 사용자 지정 훅은 **지역 상태**만 만들 수 있어 상태의 파편화를 만들어 버린다는 한계가 있다.

이를 해결하기 위해서는 컴포넌트 트리를 재설계하는 등의 수고로움이 필요하다.


### 5.2.2 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기

함수 외부에서 상태를 참조하고 이를 통해 렌더링이 일어나려면 다음과 같은 조건을 만족해야 한다.

1. 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 한다.
2. 외부에 있는 상태를 사용하는 컴포넌트는 상태의 변화를 알아챌 수 있어야 하고, 상태가 변화될 때마다 리렌더링이 일어나서 컴포넌트를 최신 상태값 기준으로 렌더링해야 한다. 이 상태 감지는 상태를 참조하는 모든 컴포넌트에서 동일하게 작동해야 한다.
3. 상태가 원시값이 아닌 객체인 경우에 그 객체에 내가 감지하는 값의 변화에만 리렌더링 되어야 한다.

상태의 이름을 store로 정의하고, store의 값이 변경될 때마다 변경됐음을 알리는 callback 함수를 실행한다. 이 callback 함수를 등록할 수 있는 subscribe 함수가 필요하다.

```jsx
type Initializer<T> = T extends any ? T | ((prev: T) => T) : never

type Store<State> = {
  get: () => State
  set: (action: Initializer<State>) => State
  subscribe: (callback: () => void) => () => void
}

export const createStore = <State extends unknwon>(
  initialState: Initializer<State>,
): Store<State> => {
  // state 또는 게으른 초기화 함수로 state 초깃값 할당
  let state = typeof initialState !== 'function' ? initialState : initialState()

  // 콜백 함수를 저장하기 위한 callbacks
  // 자료형에 관계없이 유일한 값을 저장할 수 있는 Set으로 선언
  const callbacks = new Set<() => void>()
  // get이 호출되면 매번 최신값을 가져올 수 있게 함
  const get = () => state
  const set = (nextState: State | ((prev: State) => State)) => {
    // 함수를 실행해서 새로운 값을 받거나 새로운 값을 그대로 넣어줌
    state =
      typeof nextState === 'function'
        ? (nextState as (prev: State) => State)(state)
        : nextState

    // set으로 값을 설정하는 순간 콜백을 모두 실행해 컴포넌트의 렌더링 유도
    callbacks.forEach((callback) => callback())

    return state
  }

  const subscribe = (callback: () => void) => {
    // 받은 함수를 콜백 목록에 추가
    callbacks.add(callback)

    return () => {
      callbacks.delete(callback)
    }
  }
  // get, set, subscribe을 외부에서 사용할 수 있도록 한다.
  return { get, set, subscribe }
}
```

useStore 훅으로 store의 변화를 감지해보자.

```jsx
// store를 인수로 받음
export const useStore = <State extends unknown>(store: Store<State>) => {
  // store 값을 초깃값으로 하는 state를 만듦
  // useState가 컴포넌트의 렌더링을 유도함
  const [state, setState] = useState<State>(() => store.get())

  useEffect(() => {
    // store의 현재 값을 가져와 setState를 수행하는 함수를 store의 subscribe에 등록
    // createStore 내부에서 값이 변경될 때마다 subscribe에 등록된 함수를 실행하므로
    // useStore 내부에서 store의 값이 변경될 때 state의 값이 변경되는 것이 보장된다.
    const unsubscribe = store.subscribe(() => {
      setState(store.get())
    })
    return unsubscribe
  }, [store])

  return [state, store.set] as const
}
```

store가 객체일 때, 원하는 값이 변했을 때만 리렌더링되도록 훅을 다시 구성해보자.

```jsx
export const useStoreSelector = <State extends unknown, Value extends unknown>(
  store: Store<State>,
  selector: (state: State) => Value, // 📌 두 번째 인수로 selector 함수를 받는다.
) => {
  const [state, setState] = useState<State>(() => selector(store.get()))

  useEffect(() => {
    const unsubscribe = store.subscribe(() => {
      // 📌 store 값이 변해도 selector(store.get())이 변경되지 않으면 리렌더링이 일어나지 않는다.
      const value = selector(store.get())
      setState(value)
    })

    return unsubscribe
  }, [store, selector])

  return state
}
```

useStoreSelector 훅을 사용하는 예제를 살펴보자.

```jsx
const store = creatStore({ count: 0, text: 'hi' })

// 📌 selector를 컴포넌트 밖에서 선언하거나, useCallback을 사용해 참조를 고정시켜야 한다.
// 그렇지 않으면 컴포넌트가 리렌더링될 때마다 함수가 계속 재생성되어 store의 subscribe를 반복적으로 수행할 것이다.
const textSelector = (state: ReturnType<typeof store.get>) => state.text

function TextEditor() {
  const text = useStoreSelector(store, textSelector)

  function handleChange(e: ChangeEvent<HTMLInputElement>) {
    // 컴포넌트에서 필요한 값만 select해서 사용할 수 있고
    // select 또한 실제로 객체에서 변경된 값에 대해서만 수행할 것이다.
    store.set((prev) => ({ ...prev, text: e.target.value }))
  }

  return (
    <>
      <h3>{text}</h3>
      <input value={text} onChange={handleChange} />
    </>
  )
}
```

리액트 외부에서 관리되는 값에 대한 변경을 추적하고, 이를 리렌더링까지 할 수 있는 useStoreSelector와 같은 훅이 이미 존재한다. 리액트 팀에서 만든 useSubscription이다.

```jsx
function NewCounter() {
  const subscription = useMemo(
    () => ({
      getCurrentValue: () => store.get(),
      subscribe: (callback: () => void) => {
        const unsubscribe = store.subscribe(callback)
        return () => unsubscribe()
      },
    }),
    [],
  )

  const value = useSubscription(subscription)

  return <>{JSON.stringify(value)}</>
}
```

useSubscription의 차이점은 **selector와 subscribe에 대한 비교**도 추가했다는 것이다.

위에서 만든 useStore나 useStoreSelector 모두 useEffect의 의존성 배열에 **store나 selector가** 들어가 있어 이 객체가 **임의로 변경될 경우** 불필요하게 리렌더링이 발생한다는 문제가 있다.

이를 방지하기 위해 useSubscription 내부에는 **예외 처리가 추가**되어 더 안정적으로 상태를 제공할 수 있다.

> 리액트 18 버전의 useSubscription을 살펴보면 useSubscription 훅 자체가 useSyncExternalStore로 재작성되어 있는 것을 볼 수 있다. 이에 대해서는 10.2절 '리액트 18 버전 살펴보기'에서 다룬다.
